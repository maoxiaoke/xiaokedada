<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JavaScript Promise 迷你书（中译本） | XIAOKEDADA</title>
    <meta name="description" content="Write something useful and funny">
    <link rel="icon" href="/favicon.png">
    
    <link rel="preload" href="/assets/css/68.styles.d3eb3505.css" as="style"><link rel="preload" href="/assets/js/app.843b634b.js" as="script"><link rel="preload" href="/assets/js/5.0a465bdb.js" as="script"><link rel="prefetch" href="/assets/js/35.fc0649b6.js"><link rel="prefetch" href="/assets/js/1.85421567.js"><link rel="prefetch" href="/assets/js/2.f423fd68.js"><link rel="prefetch" href="/assets/js/3.1f142fb1.js"><link rel="prefetch" href="/assets/js/4.bd68aee8.js"><link rel="prefetch" href="/assets/js/6.97e629f1.js"><link rel="prefetch" href="/assets/js/7.bb19bdef.js"><link rel="prefetch" href="/assets/js/8.5daef4ca.js"><link rel="prefetch" href="/assets/js/9.4fcb0f34.js"><link rel="prefetch" href="/assets/js/10.4376478b.js"><link rel="prefetch" href="/assets/js/11.8fc6b13a.js"><link rel="prefetch" href="/assets/js/12.1772ec65.js"><link rel="prefetch" href="/assets/js/13.a4ef0e77.js"><link rel="prefetch" href="/assets/js/14.427f03c9.js"><link rel="prefetch" href="/assets/js/15.723a7d06.js"><link rel="prefetch" href="/assets/js/16.166d836c.js"><link rel="prefetch" href="/assets/js/17.21b4f630.js"><link rel="prefetch" href="/assets/js/18.fd756ec4.js"><link rel="prefetch" href="/assets/js/19.a8b80d16.js"><link rel="prefetch" href="/assets/js/20.8e9cdb67.js"><link rel="prefetch" href="/assets/js/21.4e4f2b91.js"><link rel="prefetch" href="/assets/js/22.d28267a3.js"><link rel="prefetch" href="/assets/js/23.653fa423.js"><link rel="prefetch" href="/assets/js/24.8ed99de7.js"><link rel="prefetch" href="/assets/js/25.614045fd.js"><link rel="prefetch" href="/assets/js/26.02791f7a.js"><link rel="prefetch" href="/assets/js/27.3fa3f1e9.js"><link rel="prefetch" href="/assets/js/28.8aaaacba.js"><link rel="prefetch" href="/assets/js/29.02e1b211.js"><link rel="prefetch" href="/assets/js/30.46e3e02b.js"><link rel="prefetch" href="/assets/js/31.8af56ad3.js"><link rel="prefetch" href="/assets/js/32.091d8ef1.js"><link rel="prefetch" href="/assets/js/33.d33fb871.js"><link rel="prefetch" href="/assets/js/34.d41761e9.js"><link rel="prefetch" href="/assets/js/0.e6be7c2e.js"><link rel="prefetch" href="/assets/js/36.d0053b92.js"><link rel="prefetch" href="/assets/js/37.21574b04.js"><link rel="prefetch" href="/assets/js/38.80e207ae.js"><link rel="prefetch" href="/assets/js/39.e4995ccf.js"><link rel="prefetch" href="/assets/js/40.5d361e67.js"><link rel="prefetch" href="/assets/js/41.a50cd60b.js"><link rel="prefetch" href="/assets/js/42.caf66f0e.js"><link rel="prefetch" href="/assets/js/43.4a9eaf80.js"><link rel="prefetch" href="/assets/js/44.448792e0.js"><link rel="prefetch" href="/assets/js/45.a2c7b618.js"><link rel="prefetch" href="/assets/js/46.d5711dfe.js"><link rel="prefetch" href="/assets/js/47.b7c59a32.js"><link rel="prefetch" href="/assets/js/48.d54390f0.js"><link rel="prefetch" href="/assets/js/49.0e14e323.js"><link rel="prefetch" href="/assets/js/50.116c6f8c.js"><link rel="prefetch" href="/assets/js/51.00a2e7ea.js"><link rel="prefetch" href="/assets/js/52.96b8f0e2.js"><link rel="prefetch" href="/assets/js/53.6316d91b.js"><link rel="prefetch" href="/assets/js/54.3120e195.js"><link rel="prefetch" href="/assets/js/55.7582a732.js"><link rel="prefetch" href="/assets/js/56.eab8bc2a.js"><link rel="prefetch" href="/assets/js/57.74edb44a.js"><link rel="prefetch" href="/assets/js/58.5122e2dc.js"><link rel="prefetch" href="/assets/js/59.3ec0162a.js"><link rel="prefetch" href="/assets/js/60.8ec70531.js"><link rel="prefetch" href="/assets/js/61.fc7a010b.js"><link rel="prefetch" href="/assets/js/62.e17877aa.js"><link rel="prefetch" href="/assets/js/63.44b0382a.js"><link rel="prefetch" href="/assets/js/64.621d7404.js"><link rel="prefetch" href="/assets/js/65.755ec884.js"><link rel="prefetch" href="/assets/js/66.bfb5a72d.js"><link rel="prefetch" href="/assets/js/67.b71bf6f3.js">
    <link rel="stylesheet" href="/assets/css/68.styles.d3eb3505.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      XIAOKEDADA
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/JavaScript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/FirstMeet/" class="nav-link">FirstMeet系列</a></div><div class="nav-item"><a href="/CSS/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/ReadingNote/" class="nav-link router-link-active">读书笔记</a></div><div class="nav-item"><a href="/GatherAll/" class="nav-link">R &amp; T</a></div><a href="https://github.com/maoxiaoke/xiaokedada" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/JavaScript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/FirstMeet/" class="nav-link">FirstMeet系列</a></div><div class="nav-item"><a href="/CSS/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/ReadingNote/" class="nav-link router-link-active">读书笔记</a></div><div class="nav-item"><a href="/GatherAll/" class="nav-link">R &amp; T</a></div><a href="https://github.com/maoxiaoke/xiaokedada" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>读书笔记</span><!----></p><ul class="sidebar-group-items"><li><a href="/ReadingNote/Functional-JavaScript.html" class="sidebar-link">Functional JavaScript</a></li><li><a href="/ReadingNote/JavaScript-Promise.html" class="active sidebar-link">JavaScript Promise 迷你书（中译本）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#规范中心" class="sidebar-link">规范中心</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#什么是-promise" class="sidebar-link">什么是 Promise</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#promise-api" class="sidebar-link">Promise API</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#constructor-实例化" class="sidebar-link">Constructor - 实例化</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#instance-method" class="sidebar-link">Instance Method</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#static-method" class="sidebar-link">Static Method</a></li></ul></li><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#promise-的状态" class="sidebar-link">Promise 的状态</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#promise-的异步性" class="sidebar-link">Promise 的异步性</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#then-或-catch" class="sidebar-link">then 或 catch</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#返回-promise-的函数" class="sidebar-link">返回 Promise 的函数</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#catch-之后的-then" class="sidebar-link">catch() 之后的 then()</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#使用-reduce-顺序执行-promise" class="sidebar-link">使用 reduce() 顺序执行 promise</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#new-promise-reslove-和-promise-reslove-的区别" class="sidebar-link">new Promise (reslove) 和 Promise.reslove() 的区别</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#promise-和差错控制" class="sidebar-link">Promise 和差错控制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#基于-promise-的函数不该-throw-异常" class="sidebar-link">基于 Promise 的函数不该 throw 异常</a></li></ul></li><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#resolve-是什么" class="sidebar-link">resolve 是什么</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#promise-结合-settimeout" class="sidebar-link">Promise 结合 setTimeout()</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/JavaScript-Promise.html#返回-promise-链的函数" class="sidebar-link">返回 Promise 链的函数</a></li></ul></li><li><a href="/ReadingNote/Why-Control-Time.html" class="sidebar-link">为什么精英都是时间控</a></li><li><a href="/ReadingNote/The-Clean-Coder.html" class="sidebar-link">代码整洁之道</a></li><li><a href="/ReadingNote/Real-World-Haskell.html" class="sidebar-link">Real World Haskell</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="javascript-promise-迷你书（中译本）"><a href="#javascript-promise-迷你书（中译本）" aria-hidden="true" class="header-anchor">#</a> JavaScript Promise 迷你书（中译本）</h1><p>思考一个问题：Promise 适合什么、不适合什么？Promise 是万能的吗？</p><h2 id="规范中心"><a href="#规范中心" aria-hidden="true" class="header-anchor">#</a> 规范中心</h2><ol><li><a href>ECMAScript 6 Promises</a></li><li><a href="https://promisesaplus.com/" target="_blank" rel="noopener noreferrer">Promises/A+<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a href="https://github.com/w3ctag/promises-guide" target="_blank" rel="noopener noreferrer">w3ctag/promises-guide<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ol><h2 id="什么是-promise"><a href="#什么是-promise" aria-hidden="true" class="header-anchor">#</a> 什么是 Promise</h2><p>Promise 是抽象异步处理对象以及对其进行各种操作的组件。</p><p>Promise 最初被提出是 <code>E</code> 语言。</p><p>Node.js 中回调函数的一个例子：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">getAsync</span><span class="token punctuation">(</span><span class="token string">'fileA'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>error<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> error
  <span class="token punctuation">}</span>
  <span class="token comment">// Do something</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>这是一种错误先行的策略。</p><p>但是作者认为: 这个写法虽然很明了，但这仅仅是一个编码规约而已，即使采用其他的方法也不会出错。 而 Promise 则是把类似的异步处理对象和处理规则进行规范化，并按照采用统一的接口来编写，而采取规定方法之外的写法都会出错。</p><hr><h2 id="promise-api"><a href="#promise-api" aria-hidden="true" class="header-anchor">#</a> Promise API</h2><h3 id="constructor-实例化"><a href="#constructor-实例化" aria-hidden="true" class="header-anchor">#</a> Constructor - 实例化</h3><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 异步处理</span>
  <span class="token comment">// 处理结束后调用 resolve 或 reject</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="instance-method"><a href="#instance-method" aria-hidden="true" class="header-anchor">#</a> Instance Method</h3><h4 id="then"><a href="#then" aria-hidden="true" class="header-anchor">#</a> then()</h4><div class="language-js extra-class"><pre class="language-js"><code>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span>
</code></pre></div><p><code>resolve</code>(成功)时：</p><p>回调函数 <code>onFulfilled</code> 会被调用</p><p><code>reject</code>(失败时)：</p><p>回调函数 <code>onRejected</code> 会被调用</p><p>promise chain 传递参数，例子：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
promise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>val <span class="token operator">=&gt;</span> val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>val <span class="token operator">=&gt;</span> val <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>val <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><code>return</code> 的值可以是字符串或者数值类型，对象或者 promise。</p><blockquote><p><code>return</code> 的值会由 <code>Promise.resolve(返回值)</code> 进行一层包装处理，因此不管回调函数中会返回一个什么样的值，最终 then 的结果都是返回一个新创建的 promise 对象。</p></blockquote><h4 id="catch"><a href="#catch" aria-hidden="true" class="header-anchor">#</a> catch()</h4><p><code>catch()</code> 方法只是 <code>promise.then(undefined, onRejected)</code> 的一个别名而已。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p><strong>每次调用 <code>then</code> 和 <code>catch</code> 都会返回一个新创建的 promise 对象</strong></p></div><h3 id="static-method"><a href="#static-method" aria-hidden="true" class="header-anchor">#</a> Static Method</h3><h4 id="promise-resolve"><a href="#promise-resolve" aria-hidden="true" class="header-anchor">#</a> Promise.resolve()</h4><p>一般情况下我们可以使用 new Promise() 来创建 promise 对象，还可以使用 <code>Promise.resolve()</code> 和 <code>Promise.reject()</code>。</p><p>比如： <code>Promise.resolve(42)</code>，可以认为是以下代码的语法糖：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> rejecte<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><code>Promise.resolve()</code> 方法的另一个作用是将 <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md#thenable-duck-typing" target="_blank" rel="noopener noreferrer"><code>thenable</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 对象转换为 promise 对象。</p><blockquote><p>这种将 thenable 对象转换为 promise 对象的机制要求 thenable 对象所拥有的 then 方法应该和 promise 所拥有的 then 方法具有同样的功能和处理过程。</p></blockquote><p>比如 <a href="https://api.jquery.com/jQuery.ajax/" target="_blank" rel="noopener noreferrer"><code>jQuery.ajax()</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的返回值是 <a href="http://api.jquery.com/jQuery.ajax/#jqXHR" target="_blank" rel="noopener noreferrer"><code>jqXHR Object</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 对象，这个对象具有 <code>.then</code> 方法。这个 <code>thenable</code> 可以使用 <code>Promise.resolve()</code> 来转换为一个 promise 对象。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">'/json/comment.json'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>应当注意的是，即使有一个对象具有 <code>then</code> 方法，也不一定就能作为 Promises 对象使用。</p></blockquote><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>简单总结一下的话，可以认为它的作用就是将传递给它的参数 Fulfilled 到 promise 对象后并返回这个 promise 对象。</p></div><h4 id="promise-reject"><a href="#promise-reject" aria-hidden="true" class="header-anchor">#</a> Promise.reject()</h4><p><code>Promise.reject()</code> 正好是 <code>Promise.resolve()</code> 的对立。在编写测试代码或者进行 debug 的时候，也许用得上。</p><h4 id="promise-all"><a href="#promise-all" aria-hidden="true" class="header-anchor">#</a> Promise.all()</h4><p><code>Promise.all</code> 接收一个 promise 对象的数组作为参数，当这个数组里所有 promise 对象全部变为 Fulfilled 或 Rejected 状态的时候，它才会调用 <code>.then</code> 方法。</p><h4 id="promise-race"><a href="#promise-race" aria-hidden="true" class="header-anchor">#</a> Promise.race()</h4><p>与 <code>Promise.all</code> 相对的是，<code>Promise.race</code> Fulfilled 或 Rejected，才会进行后面的处理。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>需要注意的是，<code>Promise.race</code> 在第一个 promise 对象变成 Fulfilled 时候，并不会取消其他 promise 对象的执行。理解起来也很简单，当 promise 的状态从 Pending 开始转化时，最终会进入 Fulfilled 或 Rejected 的状态之一。</p><p>所以得到 Promise 一个不适用的场景：不适用于状态可能会固定不变的处理。</p></div><hr><h2 id="promise-的状态"><a href="#promise-的状态" aria-hidden="true" class="header-anchor">#</a> Promise 的状态</h2><p>用 <code>new Promise</code> 实例化的 <code>promise</code> 对象有以下三个状态：</p><ul><li>&quot;has-resolution&quot; - Fulfilled</li></ul><p>完成状态，此时会调用 <code>onFulfilled</code></p><ul><li>&quot;has-rejection&quot; - Rejected</li></ul><p>拒绝状态，此时会调用 <code>onRejected</code></p><ul><li>&quot;unresolved&quot; - Pending</li></ul><p>promise 对象刚被创建后的初始化状态</p><blockquote><p>左侧是 ES6 Promises 规范中的术语，右侧则是 Promises/A+ 中描述状态的术语</p></blockquote><p>对于状态的解释主要有以下几点：</p><ol><li>promise 对象的状态，从 Pending 装换为 Fullfilled 或 Rejected 对象的状态之后就不会再发生变化 - <strong>完成即不变</strong></li><li>由于第一点，所以 <code>then()</code> 后执行的函数可以肯定地说只会被调用一次</li><li>Fulfilled 和 Rejected 这两个中的任一状态都可以表示 Settled。</li></ol><hr><h2 id="promise-的异步性"><a href="#promise-的异步性" aria-hidden="true" class="header-anchor">#</a> Promise 的异步性</h2><p><code>then</code> 中指定的方法调用都是异步进行的。</p><p>可能存有疑惑的时，当 <code>Promise.resove(value)</code> 等方法解析“立即值”的时，<code>Promise</code> 对象能立即进入 Fullfilled 状态或 Rejected 状态，那为啥 <code>then</code> 里指定的方法不是同步调用的呢？</p><p>这其实是 <code>Promise</code> 的一个设计规范 - 解决异步同步调用同时存在所产生的混乱问题。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">onReady</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> readyState <span class="token operator">=</span> document<span class="token punctuation">.</span>readyState<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>readyState <span class="token operator">===</span> <span class="token string">'interactive'</span> <span class="token operator">||</span> readyState <span class="token operator">===</span> <span class="token string">'complete'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'DOMContentLoaded'</span><span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">onReady</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'DOM fully loaded and parsed'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'==Starting=='</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面这个函数，根据 DOM 是否装载完毕来决定是否对回调函数进行同步还是异步调用，这就造成同步异步产生混乱的问题。</p><p>为此，我们可以采用 <code>setTimeout(fn(), 0)</code> 进行 <strong>同步异步化</strong>。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">onReady</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> readyState <span class="token operator">=</span> document<span class="token punctuation">.</span>readyState<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>readyState <span class="token operator">===</span> <span class="token string">'interactive'</span> <span class="token operator">||</span> readyState <span class="token operator">===</span> <span class="token string">'complete'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'DOMContentLoaded'</span><span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">onReady</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'DOM fully loaded and parsed'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'==Starting=='</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><hr><h2 id="then-或-catch"><a href="#then-或-catch" aria-hidden="true" class="header-anchor">#</a> then 或 catch</h2><p>在<a href="#catch()">前面</a>我们提到过：</p><blockquote><p><code>catch()</code> 方法只是 <code>promise.then(undefined, onRejected)</code> 的一个别名而已。</p></blockquote><p>所以，对于错误处理，我们可以采用两种方式：</p><ol><li><code>promise.then(onFulfilled, onRejected)</code> 指定对错误函数的处理</li><li>使用 <code>promise.catch()</code></li></ol><p>下面是两者的异同：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throwError</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// then 方式</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>throwError<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'then 方式'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// error: Uncaught (in promise) Error: 42 at throwError (&lt;anonymous&gt;:2:9)</span>

<span class="token comment">// catch 方式</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>throwError<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'catch 方式'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 'catch 方式'</span>
</code></pre></div><p>也就是说，当使用 <code>then</code>方式 捕获错误的时候，<strong>实际上不能捕获第一个参数 <code>onFulfilled</code> 指定的函数</strong>，它针对的是自身的 promise 对象或者之前的 promise 对象。</p><p>而 <code>catch</code> 方式，则遵循了 <code>throwError</code> -&gt; <code>onRejected</code> 的方式。</p><p>所以，<code>catch</code> 方式是最佳实践。</p><p>下面都是<a href="https://github.com/maoxiaoke" target="_blank" rel="noopener noreferrer">我<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 加的内容。</p><h2 id="返回-promise-的函数"><a href="#返回-promise-的函数" aria-hidden="true" class="header-anchor">#</a> 返回 Promise 的函数</h2><p>比如下面的这个函数：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">aPromise</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>                      <span class="token comment">// Task 1</span>
    <span class="token keyword">return</span> <span class="token number">2</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token comment">// Catch 2</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> bPromise <span class="token operator">=</span> <span class="token function">aPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">aPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p><code>aPromise()</code> 返回的一个 Promise，对于 <code>bPromise</code> 而言，是函数 <code>aPromise()</code> 最终的 <code>resolve</code> 或 <code>reject</code> 的值(即 Task 1 的完成值)。</p><p>在标识一个 Promise 时，通常是一个这样的方式：</p><div class="language- extra-class"><pre class="language-text"><code>[[PromiseStatus]]: &quot;resolved&quot;
[[PromiseValue]]: undefined
</code></pre></div><p>即两个内部属性 <code>[PromiseStatus]]</code> 和 <code>[[PromiseValue]]</code>。对于每个 Promise 的分析都可以采用这样的结构方式。上例的 <code>bPromise</code> 的 <code>[[PromiseStatus]]</code> 应该是 <code>&quot;resolved&quot;</code>，而 <code>[[PromiseValue]]</code> 是 <code>2</code>。</p><p>对于很多类似的问题，都可以采用这种思考方式。</p><h2 id="catch-之后的-then"><a href="#catch-之后的-then" aria-hidden="true" class="header-anchor">#</a> catch() 之后的 then()</h2><p>一般来说，我们将 <code>catch()</code> 放在 <code>then()</code> 链的最后，以便 <em>捕获链上的任何错误</em>。</p><p>但是仍可以有 <code>then().catch().then().catch()</code> 这样的链方式。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">aPromise</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token string">'error'</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>                        <span class="token comment">// Task 1</span>
  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// Catch 1</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment">// Task 2</span>
  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token comment">// Catch 2</span>
<span class="token punctuation">}</span>
</code></pre></div><p>执行顺序是，就算 Catch 1 捕获到 Task 1 的错误，Task 2 仍然执行。Catch 2 只能捕获 Task 2 的错误；Task 1 的错误由 Catch 1 捕获。</p><h2 id="使用-reduce-顺序执行-promise"><a href="#使用-reduce-顺序执行-promise" aria-hidden="true" class="header-anchor">#</a> 使用 reduce() 顺序执行 promise</h2><p><code>Array.prototype.reduce()</code> 是一个非常函数化的方法，其语义化为：通过在循环时将结果存储在累加器(accumulator)中，从而把一堆东西减少(reduce)为一个。</p><p>比如，有一批挨个处理的数据，当其顺序执行到最后一个都返回 Fulfilled 时，执行成功；其中有一个返回 Rejected 时， 执行失败。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> tasks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>

<span class="token keyword">function</span> <span class="token function">methodThatReturnsAPromise</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
tasks<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>previousPromise<span class="token punctuation">,</span> nextID<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> previousPromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">methodThatReturnsAPromise</span><span class="token punctuation">(</span>nextID<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>倘若使用 <code>async/await</code> 语法。可以更为直接一点：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> tasks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
tasks<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span>previousPromise<span class="token punctuation">,</span> nextID<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> previousPromise
  <span class="token keyword">return</span> <span class="token function">methodThatReturnsAPromise</span><span class="token punctuation">(</span>nextID<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>相较于 <code>Promise.all([ task1, task2, task3 ])</code>，两者是有区别的。</p><ul><li>其一，<code>Promise.all([ task1, task2, task3 ])</code> 是同时开始，并行执行的。而采用 <code>reduce()</code> 方法的是顺序执行的。</li><li>其二，<code>Promise.all([ task1, task2, task3 ])</code> 适合 tasks 长度短且 task 不相似的情况。</li></ul></div><p>我们还可以思考一下变种：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> tasks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> promise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> nextID <span class="token keyword">of</span> tasks<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  promise <span class="token operator">=</span> promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">methodThatReturnsAPromise</span><span class="token punctuation">(</span>nextID<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实际上这种方式并不能达到我们的要求，因为 <code>for...in</code> 总是同步进行的。实际上上述代码的运行情况如下：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> tasks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> promise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// loop 1</span>
promise <span class="token operator">=</span> promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">methodThatReturnsAPromise</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// loop 2</span>
promise <span class="token operator">=</span> promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">methodThatReturnsAPromise</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// loop 3</span>
promise <span class="token operator">=</span> promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">methodThatReturnsAPromise</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>如果你对<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener noreferrer">轮询机制<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 比较了解的话，最终的结果应该是最后完成的 resolve 或 reject。</p><p>对于上述的变种，如下：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">handleSequencePromise</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> nextID <span class="token keyword">of</span> tasks<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token keyword">await</span> <span class="token function">promiseReturningMethod</span><span class="token punctuation">(</span>nextID<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="new-promise-reslove-和-promise-reslove-的区别"><a href="#new-promise-reslove-和-promise-reslove-的区别" aria-hidden="true" class="header-anchor">#</a> new Promise (reslove) 和 Promise.reslove() 的区别</h2><p>正如在上面提到的。我们可以认为 <code>Promise.resolve(42)</code>，是下列代码的语法糖：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><p>但两者表达试图表达的含义并非一致。</p><p><code>Promise.resolve()</code> 创建的是一个已经 resolved 的 promise，而 <code>new Promise(resolve)</code> 除了可以创建已经 resolved 或 rejected 的 promise (如果是这类情况，实际上跟 Promise.resolve() 和 Promise.reject() 的表现并无二致)，还可以创建处于 Pending 状态的 promise (这一点才是 new Promise(reslove) 真正发挥实力的地方)。</p><p>下面的例子中，会使用 <code>setTimeout()</code> 来模拟一个异步函数。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">delay</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span>resolve <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'DONE'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> ms<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span>
<span class="token comment">/*
在 10s 之前， `x` 的状态为：
[[PromiseStatus]]: &quot;pending&quot;
[[PromiseValue]]: undefined

10s 之后，`x` 的状态为：
[[PromiseStatus]]: &quot;resolved&quot;
[[PromiseValue]]: &quot;DONE&quot;
*/</span>
</code></pre></div><h2 id="promise-和差错控制"><a href="#promise-和差错控制" aria-hidden="true" class="header-anchor">#</a> Promise 和差错控制</h2><h3 id="基于-promise-的函数不该-throw-异常"><a href="#基于-promise-的函数不该-throw-异常" aria-hidden="true" class="header-anchor">#</a> 基于 Promise 的函数不该 throw 异常</h3><p>我们知道，<code>throw</code> 是 JavaScript 主动抛出异常的一种方式。比如，我们用在 Promise 当中：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 使用 `throw` 抛出错误</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// &quot;error&quot;</span>

<span class="token comment">// 使用 reject 方式</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// &quot;error&quot;</span>
</code></pre></div><p>看上去两者似乎表现一致，但 <code>throw</code> 是<strong>同步</strong>抛出错误，最终被 catch 捕获；而 <code>reject</code> 是将该 Promise 的 <code>[[PromiseStatus]]</code> 置为 <code>rejected</code>，是一种异步行为。</p><p>为什么用 <code>reject</code> 而不是 <code>throw</code> ?</p><h2 id="resolve-是什么"><a href="#resolve-是什么" aria-hidden="true" class="header-anchor">#</a> resolve 是什么</h2><h2 id="promise-结合-settimeout"><a href="#promise-结合-settimeout" aria-hidden="true" class="header-anchor">#</a> Promise 结合 setTimeout()</h2><h2 id="返回-promise-链的函数"><a href="#返回-promise-链的函数" aria-hidden="true" class="header-anchor">#</a> 返回 Promise 链的函数</h2><p>如何？？？</p><p>文章有参考：</p><ul><li><a href="https://css-tricks.com/why-using-reduce-to-sequentially-resolve-promises-works/" target="_blank" rel="noopener noreferrer">Why Using reduce() to Sequentially Resolve Promises Works<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a href="https://decembersoft.com/posts/promises-in-serial-with-array-reduce/" target="_blank" rel="noopener noreferrer">Back to Basics: Running Promises in Serial with Array.reduce()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a href="https://github.com/yoshuawuyts/promise-reduce/blob/master/index.js#L21:42" target="_blank" rel="noopener noreferrer">promise-reduce的一个库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><p>TODO:</p><ul><li>[] Difference between returning a promise vs returning undefined inside a promise</li><li>[] JavaScript Promises - reject vs. throw</li><li>[] new Promise 没有 return，却有返回</li><li>[] try...catch/ 差错控制</li></ul></div><div class="page-edit"><div class="edit-link"><a href="https://github.com/maoxiaoke/xiaokedada/edit/master/ReadingNote/JavaScript-Promise.md" target="_blank" rel="noopener noreferrer">在 Github 上编辑此页</a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div><!----></div><div class="page-nav"><p class="inner"><span class="prev">
        ← <a href="/ReadingNote/Functional-JavaScript.html" class="prev">
          Functional JavaScript
        </a></span><span class="next"><a href="/ReadingNote/Why-Control-Time.html">
          为什么精英都是时间控
        </a> →
      </span></p></div></div></div></div>
    <script src="/assets/js/5.0a465bdb.js" defer></script><script src="/assets/js/app.843b634b.js" defer></script>
  </body>
</html>
