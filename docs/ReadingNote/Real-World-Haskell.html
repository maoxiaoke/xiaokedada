<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Real World Haskell | XIAOKEDADA</title>
    <meta name="description" content="Write something useful and funny">
    <link rel="icon" href="/favicon.png">
    
    <link rel="preload" href="/assets/css/68.styles.d3eb3505.css" as="style"><link rel="preload" href="/assets/js/app.843b634b.js" as="script"><link rel="preload" href="/assets/js/2.f423fd68.js" as="script"><link rel="prefetch" href="/assets/js/35.fc0649b6.js"><link rel="prefetch" href="/assets/js/1.85421567.js"><link rel="prefetch" href="/assets/js/3.1f142fb1.js"><link rel="prefetch" href="/assets/js/4.bd68aee8.js"><link rel="prefetch" href="/assets/js/5.0a465bdb.js"><link rel="prefetch" href="/assets/js/6.97e629f1.js"><link rel="prefetch" href="/assets/js/7.bb19bdef.js"><link rel="prefetch" href="/assets/js/8.5daef4ca.js"><link rel="prefetch" href="/assets/js/9.4fcb0f34.js"><link rel="prefetch" href="/assets/js/10.4376478b.js"><link rel="prefetch" href="/assets/js/11.8fc6b13a.js"><link rel="prefetch" href="/assets/js/12.1772ec65.js"><link rel="prefetch" href="/assets/js/13.a4ef0e77.js"><link rel="prefetch" href="/assets/js/14.427f03c9.js"><link rel="prefetch" href="/assets/js/15.723a7d06.js"><link rel="prefetch" href="/assets/js/16.166d836c.js"><link rel="prefetch" href="/assets/js/17.21b4f630.js"><link rel="prefetch" href="/assets/js/18.fd756ec4.js"><link rel="prefetch" href="/assets/js/19.a8b80d16.js"><link rel="prefetch" href="/assets/js/20.8e9cdb67.js"><link rel="prefetch" href="/assets/js/21.4e4f2b91.js"><link rel="prefetch" href="/assets/js/22.d28267a3.js"><link rel="prefetch" href="/assets/js/23.653fa423.js"><link rel="prefetch" href="/assets/js/24.8ed99de7.js"><link rel="prefetch" href="/assets/js/25.614045fd.js"><link rel="prefetch" href="/assets/js/26.02791f7a.js"><link rel="prefetch" href="/assets/js/27.3fa3f1e9.js"><link rel="prefetch" href="/assets/js/28.8aaaacba.js"><link rel="prefetch" href="/assets/js/29.02e1b211.js"><link rel="prefetch" href="/assets/js/30.46e3e02b.js"><link rel="prefetch" href="/assets/js/31.8af56ad3.js"><link rel="prefetch" href="/assets/js/32.091d8ef1.js"><link rel="prefetch" href="/assets/js/33.d33fb871.js"><link rel="prefetch" href="/assets/js/34.d41761e9.js"><link rel="prefetch" href="/assets/js/0.e6be7c2e.js"><link rel="prefetch" href="/assets/js/36.d0053b92.js"><link rel="prefetch" href="/assets/js/37.21574b04.js"><link rel="prefetch" href="/assets/js/38.80e207ae.js"><link rel="prefetch" href="/assets/js/39.e4995ccf.js"><link rel="prefetch" href="/assets/js/40.5d361e67.js"><link rel="prefetch" href="/assets/js/41.a50cd60b.js"><link rel="prefetch" href="/assets/js/42.caf66f0e.js"><link rel="prefetch" href="/assets/js/43.4a9eaf80.js"><link rel="prefetch" href="/assets/js/44.448792e0.js"><link rel="prefetch" href="/assets/js/45.a2c7b618.js"><link rel="prefetch" href="/assets/js/46.d5711dfe.js"><link rel="prefetch" href="/assets/js/47.b7c59a32.js"><link rel="prefetch" href="/assets/js/48.d54390f0.js"><link rel="prefetch" href="/assets/js/49.0e14e323.js"><link rel="prefetch" href="/assets/js/50.116c6f8c.js"><link rel="prefetch" href="/assets/js/51.00a2e7ea.js"><link rel="prefetch" href="/assets/js/52.96b8f0e2.js"><link rel="prefetch" href="/assets/js/53.6316d91b.js"><link rel="prefetch" href="/assets/js/54.3120e195.js"><link rel="prefetch" href="/assets/js/55.7582a732.js"><link rel="prefetch" href="/assets/js/56.eab8bc2a.js"><link rel="prefetch" href="/assets/js/57.74edb44a.js"><link rel="prefetch" href="/assets/js/58.5122e2dc.js"><link rel="prefetch" href="/assets/js/59.3ec0162a.js"><link rel="prefetch" href="/assets/js/60.8ec70531.js"><link rel="prefetch" href="/assets/js/61.fc7a010b.js"><link rel="prefetch" href="/assets/js/62.e17877aa.js"><link rel="prefetch" href="/assets/js/63.44b0382a.js"><link rel="prefetch" href="/assets/js/64.621d7404.js"><link rel="prefetch" href="/assets/js/65.755ec884.js"><link rel="prefetch" href="/assets/js/66.bfb5a72d.js"><link rel="prefetch" href="/assets/js/67.b71bf6f3.js">
    <link rel="stylesheet" href="/assets/css/68.styles.d3eb3505.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      XIAOKEDADA
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/JavaScript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/FirstMeet/" class="nav-link">FirstMeet系列</a></div><div class="nav-item"><a href="/CSS/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/ReadingNote/" class="nav-link router-link-active">读书笔记</a></div><div class="nav-item"><a href="/GatherAll/" class="nav-link">R &amp; T</a></div><a href="https://github.com/maoxiaoke/xiaokedada" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/JavaScript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/FirstMeet/" class="nav-link">FirstMeet系列</a></div><div class="nav-item"><a href="/CSS/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/ReadingNote/" class="nav-link router-link-active">读书笔记</a></div><div class="nav-item"><a href="/GatherAll/" class="nav-link">R &amp; T</a></div><a href="https://github.com/maoxiaoke/xiaokedada" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>读书笔记</span><!----></p><ul class="sidebar-group-items"><li><a href="/ReadingNote/Functional-JavaScript.html" class="sidebar-link">Functional JavaScript</a></li><li><a href="/ReadingNote/JavaScript-Promise.html" class="sidebar-link">JavaScript Promise 迷你书（中译本）</a></li><li><a href="/ReadingNote/Why-Control-Time.html" class="sidebar-link">为什么精英都是时间控</a></li><li><a href="/ReadingNote/The-Clean-Coder.html" class="sidebar-link">代码整洁之道</a></li><li><a href="/ReadingNote/Real-World-Haskell.html" class="active sidebar-link">Real World Haskell</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ReadingNote/Real-World-Haskell.html#环境配置" class="sidebar-link">环境配置</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/Real-World-Haskell.html#数据" class="sidebar-link">数据</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/Real-World-Haskell.html#类型" class="sidebar-link">类型</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/Real-World-Haskell.html#函数" class="sidebar-link">函数</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/Real-World-Haskell.html#递归" class="sidebar-link">递归</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/Real-World-Haskell.html#高阶函数" class="sidebar-link">高阶函数</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/Real-World-Haskell.html#module-系统" class="sidebar-link">module 系统</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/Real-World-Haskell.html#自己的-type-和-typeclass" class="sidebar-link">自己的 Type 和 Typeclass</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/Real-World-Haskell.html#io" class="sidebar-link">IO</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/Real-World-Haskell.html#functor" class="sidebar-link">Functor</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/Real-World-Haskell.html#monad" class="sidebar-link">monad</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/Real-World-Haskell.html#monoids" class="sidebar-link">Monoids</a></li></ul></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="real-world-haskell"><a href="#real-world-haskell" aria-hidden="true" class="header-anchor">#</a> Real World Haskell</h1><p>资源链接</p><ul><li><a href="https://wiki.haskell.org/Haskell" target="_blank" rel="noopener noreferrer">wiki Haskell<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a href="https://wiki.haskell.org/Typeclassopedia#Definition" target="_blank" rel="noopener noreferrer">typeclass<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><h2 id="环境配置"><a href="#环境配置" aria-hidden="true" class="header-anchor">#</a> 环境配置</h2><ol><li>编程环境</li></ol><ul><li>下载并安装 <a href="https://www.haskell.org/platform/" target="_blank" rel="noopener noreferrer">Haskell Platform<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li>在线编程环境 <a href="http://www.tryhaskell.org/" target="_blank" rel="noopener noreferrer">Try Haskell<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><ol start="2"><li>REPL</li></ol><ul><li>进入界面 <code>$ ghci</code></li><li>退出界面 ctrl + D</li></ul><ol start="3"><li>加载模块</li></ol><ul><li><code>Prelude</code> - 序幕。默认的模块</li><li>加载其他模块 - <code>:module + [模块名]</code>。缩写为: <code>:m + [模块名]</code></li><li>替代默认的提示符 - <code>:set prompt &quot;ghci&gt;&quot;</code></li></ul><h2 id="数据"><a href="#数据" aria-hidden="true" class="header-anchor">#</a> 数据</h2><ol><li>简单的运算</li></ol><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> 2 * 3
</code></pre></div><p>都是函数。<code>*</code> 是一个两数相乘的函数，是一个 “中缀函数”。其他大多数不能和数夹在一起则称为 “前缀函数”。</p><ol start="2"><li>布尔</li></ol><p><code>True</code> 和 <code>False</code></p><ol start="3"><li>Lists</li></ol><ul><li>[1,2,3] - 是 1:2:3:[] 的语法糖</li><li>[1..5] 变成 [1,2,3,4,5]， <code>..</code> 是 enumeration notation。这种方式也叫做 Range</li><li>[1,3..8] 变成 [1,3,5,7]</li><li>[1..] 生成一个无限列表</li><li>1 : [2,3] 用于添加一个元素列表的头部。读作 <code>cons</code>(construct)</li><li>[1,2] ++ [3,4] 用于连接两个列表</li><li><code>&gt;</code> 和 <code>&gt;=</code> 可以比较 List 的大小</li></ul><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token punctuation">[</span>3,2,1<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token punctuation">[</span>2, 10, 5<span class="token punctuation">]</span>
True
</code></pre></div><p>因为 Head [3,2,1] &gt; Head [2,10,5] 所以，为 True</p><p>常用的函数：</p><ul><li>head - 返回首元素</li><li>tail - 尾部，除去首元素的部分</li><li>last - 返回尾元素</li><li>init - 首部，除去尾元素的部分</li></ul><p><img src="https://learnyoua.haskell.sg/content/zh-cn/ch02/listmonster.png" alt></p><ul><li>length - List 长度</li><li>null - 检查是否为空</li><li>reverse - 反转</li><li>take - 返回前几个元素</li></ul><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> take 3 <span class="token punctuation">[</span>1,2,4,5<span class="token punctuation">]</span>
<span class="token punctuation">[</span>1,2,4<span class="token punctuation">]</span>
</code></pre></div><ul><li>drop - 删除前几个元素</li><li>maximum - 返回最大的那个</li><li>minimun - 返回最小的那个</li><li>sum - 返回所有元素的和</li><li>product - 返回所有元素的积</li><li>elem - 判断一个元素是否存在。“中缀函数”</li></ul><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> 4 <span class="token variable"><span class="token variable">`</span>elem<span class="token variable">`</span></span> <span class="token punctuation">[</span>1,2,4,5<span class="token punctuation">]</span>
True
</code></pre></div><p>无限 List 的作用</p><p>无限 List 是一种常见 List。</p><ul><li>[1..]</li><li>cycle 函数 <code>cycle [1,2,3]</code></li><li>repeat 函数 <code>repeat 5</code></li></ul><p>由于 Haskell 是惰性的。因此：</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> take 10 <span class="token punctuation">(</span>cycle <span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span>1,2,3,1,2,3,1,2,3,1<span class="token punctuation">]</span>
</code></pre></div><p>List Comprehension</p><p>Set Comprehension(集合的表示法) 的应用。限制条件(predicate) 由 <code>,</code> 分隔。</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token punctuation">[</span>x*2 <span class="token operator">|</span> x <span class="token operator">&lt;</span>- <span class="token punctuation">[</span>1<span class="token punctuation">..</span>4<span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>2,4,6,8<span class="token punctuation">]</span>

ghci<span class="token operator">&gt;</span> <span class="token punctuation">[</span>x*2 <span class="token operator">|</span> x <span class="token operator">&lt;</span>- <span class="token punctuation">[</span>1<span class="token punctuation">..</span>10<span class="token punctuation">]</span>, x*2 <span class="token operator">&gt;=</span> 12<span class="token punctuation">]</span>
<span class="token punctuation">[</span>12,14,16,18,20<span class="token punctuation">]</span>

ghci<span class="token operator">&gt;</span> <span class="token punctuation">[</span> x*y <span class="token operator">|</span> x <span class="token operator">&lt;</span>- <span class="token punctuation">[</span>2,5,10<span class="token punctuation">]</span>, y <span class="token operator">&lt;</span>- <span class="token punctuation">[</span>8,10,11<span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>16,20,22,40,50,55,80,100,110<span class="token punctuation">]</span>
</code></pre></div><p>还可以用在函数中。</p><div class="language-bash extra-class"><pre class="language-bash"><code>len' xs <span class="token operator">=</span> <span class="token function">sum</span> <span class="token punctuation">[</span>1 <span class="token operator">|</span> _ <span class="token operator">&lt;</span>- xs <span class="token punctuation">]</span>
</code></pre></div><p><code>_</code> 意思是说，不关心从 <code>xs</code> 取什么值。</p><ol start="4"><li>Tuple</li></ol><p>形如：<code>(1,2)</code></p><ul><li>括号括起来，逗号分隔开</li><li><em>元</em> 可以保存多种类型，元组内的所有 <code>元</code> 类型必须一一对应</li><li>每个不同长度的 Tuple 都是独立的类型</li><li>长度为 2 的 Tuple 也称为 序对(Pair)</li><li>没有单元素的 Tuple</li></ul><p>常用函数：</p><ul><li>fst - 返回 序对 的首项</li></ul><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> fst <span class="token punctuation">(</span><span class="token string">&quot;Wow&quot;</span>,False<span class="token punctuation">)</span>
False
</code></pre></div><ul><li>snd - 返回 序对 的尾项</li><li>zip - 用来生成一组 序对 的 List</li></ul><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token function">zip</span> <span class="token punctuation">[</span>1<span class="token punctuation">..</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">&quot;one&quot;</span>, <span class="token string">&quot;two&quot;</span>, <span class="token string">&quot;three&quot;</span>, <span class="token string">&quot;four&quot;</span>, <span class="token string">&quot;five&quot;</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span>1,<span class="token string">&quot;one&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span>2,<span class="token string">&quot;two&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span>3,<span class="token string">&quot;three&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span>4,<span class="token string">&quot;four&quot;</span><span class="token punctuation">)</span>,<span class="token punctuation">(</span>5,<span class="token string">&quot;five&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre></div><ol start="5"><li>字符串和字符</li></ol><ul><li>Haskell 区分字符串和字符 <code>&quot;&quot;</code> for 字符串；<code>''</code> for 字符。</li><li><code>&quot;&quot;</code> 表示空串，<code>&quot;&quot; == []</code> 为 True</li><li>同 Lists 的 <code>:</code> 和 <code>++</code></li><li>&quot;Hello&quot; 只是 ['h','e','l','l','o'] 的语法糖</li></ul><h2 id="类型"><a href="#类型" aria-hidden="true" class="header-anchor">#</a> 类型</h2><p>查看类型</p><ol><li><p>在 Haskell 中，所有类型都是 <em>大写字母</em> 开头，所有的变量名字都已 <em>小写字母</em> 开头。</p></li><li><p>在 REPL 查看类型 <code>:set +t</code>；取消查看 <code>:unset +t</code></p></li><li><p>还可以用 <code>:type</code>。用法 <code>:type 'a'</code></p></li><li><p><code>it</code> 是个特殊的变量，ghci 将最近一次求值所得的结果保存在这个变量里。</p></li></ol><p>什么是类型</p><p>在 Haskell 中， 每个表达式都有类型，表明这一表达式所属的范畴。同时，Haskell 也支持类型推导。</p><p>函数也有类型。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">addThree</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">addThree</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span> <span class="token operator">+</span> <span class="token hvariable">z</span>
</code></pre></div><p>常见的类型</p><ul><li>Int - 整型，有上界和下界的那种</li><li>Integer - 整数，可以存放非常大的数。</li><li>Float - 单精度浮点数</li><li>Double - 双精度浮点数</li><li>Bool - 布尔值</li><li>Char - 字符</li></ul><p>类型变量 Type variables</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :t <span class="token function">head</span>
<span class="token function">head</span> :: <span class="token punctuation">[</span>a<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> a
</code></pre></div><p><code>a</code> 是一个类型变量，也就是说 <code>a</code> 是任何类型。使用到类型变量的函数别称为 “多态函数”。</p><p>Typeclasses</p><p>比如，<code>==</code> 的函数声明：</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :t <span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> :: <span class="token punctuation">(</span>Eq a<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> a -<span class="token operator">&gt;</span> a -<span class="token operator">&gt;</span> Bool
</code></pre></div><p><code>=&gt;</code> 左边的是类型约束。表示这两个参数的类型同在 Eq 类之中。Eq 这一 Typeclass 提供了判断相等性的接口。</p><p>类型定义行为的接口，如果一个类型属于某个 Typeclass，那它必实现该 Typeclass 所描述的行为。</p><p>几个基本的 Typeclass:</p><ul><li>Eq 包含可判断相等性的类型。只要一个函数有 Eq 类的限制，那么它就必定在定义中用到了 <code>==</code> 和 <code>/=</code>。</li><li>Ord 包含可比较大小的类型。类型若要称为 Ord 的成员，必先加入 Eq 家族。</li><li>Show 的成员可用字符串表示的类型。操作 Show Typeclass，最常用的函数表示 <code>show</code>。</li><li>Read 是与 Show 相反的 Typeclass。read 函数可以将一个字符串转为 Read 的某成员类型。</li><li>Enum 的成员都是连续的类型，即可枚举。包含的类型有： ()、Bool、Char、Ordering、Int、Integer、Float 和 Double。</li><li>Bounded 的成员都有一个上限和下限。</li><li>Num 表示数字的 TypeClass，成员类型都具有数字的特征。</li><li>Integral 同样表示数字的 TypeClass。Num 包含所有的数字；而 Integral 仅包含整数。其成员类型有 Int 和 Integer。</li><li>Floating 仅包含浮点类型：Float 和 Double。</li></ul><h2 id="函数"><a href="#函数" aria-hidden="true" class="header-anchor">#</a> 函数</h2><ol><li>函数调用的形式</li></ol><p>形式是：函数名 空格 空格分隔的参数表</p><ol start="2"><li>函数的声明</li></ol><p>为：函数名 空格分隔的参数表 = 函数行为</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token operator">//</span> <span class="token hvariable">baby</span><span class="token punctuation">.</span><span class="token hvariable">haskell</span>
<span class="token hvariable">doubleMe</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">x</span>
</code></pre></div><p>在 REPL 装载：<code>:l baby.haskell</code></p><ol start="3"><li><p>函数一定要返回一个结果</p></li><li><p>函数名首字母小写</p></li><li><p>没有参数的函数通常称为 定义 或 名字</p></li></ol><p>为： 函数名 = 函数行为</p><p>模式匹配 - Pattern matching</p><p>模式匹配通过检查数据的特定结构来检查其是否匹配。</p><p>用递归的方式实现阶乘。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">factorial</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integral</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">factorial</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token hvariable">factorial</span> <span class="token hvariable">n</span> <span class="token operator">=</span> <span class="token hvariable">n</span> <span class="token operator">*</span> <span class="token hvariable">factorial</span> <span class="token punctuation">(</span><span class="token hvariable">n</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p>模式的顺序很重要：它总是优先匹配最符合的那个，最后才是那个万能的匹配。</p><p>Tuple 也可以匹配。比如，有个函数将二维空间的矢量相加。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">addVectors</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">addVectors</span> <span class="token punctuation">(</span><span class="token hvariable">x1</span><span class="token punctuation">,</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">x2</span><span class="token punctuation">,</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x1</span> <span class="token operator">+</span> <span class="token hvariable">x2</span><span class="token punctuation">,</span> <span class="token hvariable">y1</span> <span class="token operator">+</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span>
</code></pre></div><p>List 也可以进行匹配。我们只需要知道 [1,2,3] 本质只是 1:2:3:[] 的语法糖就行。</p><p>比如 <code>x:xs</code> 匹配的就是 List 的头部绑定为 x，除头部以外的部分绑定为 xs。</p><p>之前我们用 List Comprehension 实现自己的 len 函数，现在我们用模式匹配和递归来重新实现它。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">len</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
<span class="token hvariable">len</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token hvariable">len</span>' <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token hvariable">len</span>' <span class="token hvariable">xs</span>
</code></pre></div><p>还有一种叫 as 模式，可以保留整体的引用。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">capital</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">capital</span> <span class="token string">&quot;&quot;</span> <span class="token operator">=</span> <span class="token string">&quot;Empty string, whoops&quot;</span>
<span class="token hvariable">captial</span> <span class="token builtin">all</span><span class="token operator">@</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&quot;The first letter of &quot;</span> <span class="token operator">++</span> <span class="token builtin">all</span> <span class="token operator">++</span> <span class="token string">&quot; is &quot;</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
</code></pre></div><p>Guards</p><p>guard 用来检查一个值得某项属性是否为真。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">bmi</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">18.5</span> <span class="token operator">=</span> <span class="token string">&quot;You're underweight, you emo, you!&quot;</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">25.0</span> <span class="token operator">=</span> <span class="token string">&quot;You're supposedly normal. Pffft, I bet you're ugly!&quot;</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">30.0</span> <span class="token operator">=</span> <span class="token string">&quot;You're fat! Lose some weight, fatty!&quot;</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>   <span class="token operator">=</span> <span class="token string">&quot;You're a whale, congratulations!&quot;</span>
</code></pre></div><p>非常像好多 if 语句，只不过放在了 <code>=</code> 的前面。</p><p>比如我们可以自己实现 max 函数。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">max</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">max</span>' <span class="token hvariable">a</span> <span class="token hvariable">b</span>
    <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">&gt;</span> <span class="token hvariable">b</span> <span class="token operator">=</span>     <span class="token hvariable">a</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">b</span>
</code></pre></div><p>where 可以帮助我们提示代码可读性、减少重复率、不污染命名空间等优点。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">bmi</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token hvariable">skinny</span> <span class="token operator">=</span> <span class="token string">&quot;You're underweight, you emo, you!&quot;</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token hvariable">normal</span> <span class="token operator">=</span> <span class="token string">&quot;You're supposedly normal. Pffft, I bet you're ugly!&quot;</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token hvariable">fat</span>    <span class="token operator">=</span> <span class="token string">&quot;You're fat! Lose some weight, fatty!&quot;</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>     <span class="token operator">=</span> <span class="token string">&quot;You're a whale, congratulations!&quot;</span>
    <span class="token keyword">where</span> <span class="token hvariable">skinny</span> <span class="token operator">=</span> <span class="token number">18.5</span>
          <span class="token hvariable">normal</span> <span class="token operator">=</span> <span class="token number">25.0</span>
          <span class="token hvariable">fat</span> <span class="token operator">=</span> <span class="token number">30.0</span>
</code></pre></div><p>where 也可以用模式匹配。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">bmi</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token hvariable">skinny</span> <span class="token operator">=</span> <span class="token string">&quot;You're underweight, you emo, you!&quot;</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token hvariable">normal</span> <span class="token operator">=</span> <span class="token string">&quot;You're supposedly normal. Pffft, I bet you're ugly!&quot;</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token hvariable">fat</span>    <span class="token operator">=</span> <span class="token string">&quot;You're fat! Lose some weight, fatty!&quot;</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>     <span class="token operator">=</span> <span class="token string">&quot;You're a whale, congratulations!&quot;</span>
    <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token hvariable">skinny</span><span class="token punctuation">,</span> <span class="token hvariable">normal</span><span class="token punctuation">,</span> <span class="token hvariable">fat</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">18.5</span><span class="token punctuation">,</span> <span class="token number">25.0</span><span class="token punctuation">,</span> <span class="token number">30.0</span><span class="token punctuation">)</span>
</code></pre></div><p>where 不一定非得用在 Guard 中，比如我们得到一个姓名的首字母:</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">initials</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">initials</span> <span class="token hvariable">firstname</span> <span class="token hvariable">lastname</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">f</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token string">&quot;. &quot;</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">l</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token string">&quot;.&quot;</span>
    <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">firstname</span>
          <span class="token punctuation">(</span><span class="token hvariable">l</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">lastname</span>
</code></pre></div><p>where 还可以定义函数。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">calcBmis</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">calcBmis</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">bmi</span> <span class="token hvariable">w</span> <span class="token hvariable">h</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token hvariable">w</span><span class="token punctuation">,</span> <span class="token hvariable">h</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">]</span>
    <span class="token keyword">where</span> <span class="token hvariable">bmi</span> <span class="token hvariable">weight</span> <span class="token hvariable">height</span> <span class="token operator">=</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span>
</code></pre></div><p>let 关键字</p><p>let 的使用方式是 <code>let [bindings] in [expressions]</code>。let 绑定是个表达式，允许你在任何位置定义局部变量。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">cylinder</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">cylinder</span> <span class="token hvariable">r</span> <span class="token hvariable">h</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token hvariable">sideArea</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">*</span> <span class="token hvariable">h</span>
        <span class="token hvariable">topArea</span> <span class="token operator">=</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">^</span><span class="token number">2</span>
    <span class="token keyword">in</span>  <span class="token hvariable">sideArea</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token hvariable">topArea</span>
</code></pre></div><p>或定义局部函数；</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token keyword">let</span> <span class="token hvariable">square</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">x</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token hvariable">square</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token hvariable">square</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token hvariable">square</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre></div><p>case expressions</p><p>case 也是表达式。可以对变量的不同情况分别求值，还可以使用模式匹配。模式匹配不过是 case 语句的语法糖而已。模式匹配只能在定义函数时使用，而 case 表达式可以用在任何地方。</p><p>比如我们的阶乘函数。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">factorial</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integral</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">factorial</span> <span class="token hvariable">n</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token hvariable">n</span> <span class="token keyword">of</span> <span class="token number">0</span> <span class="token operator">-&gt;</span> <span class="token number">1</span>
                        <span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token hvariable">n</span> <span class="token operator">*</span> <span class="token hvariable">factorial</span> <span class="token punctuation">(</span><span class="token hvariable">n</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p>case 的语法：</p><div class="language- extra-class"><pre class="language-text"><code>case expression of pattern -&gt; result
                   pattern -&gt; result
                   pattern -&gt; result
</code></pre></div><h2 id="递归"><a href="#递归" aria-hidden="true" class="header-anchor">#</a> 递归</h2><p>递归在 Haskell 非常重要：Haskell 中没有 while 或 for 循环。因为命令式语言倾向于提供求解的步骤，haskell 更倾向于提供问题的描述。</p><p>固定的模式是：先定义一个边界条件，再定义个函数，让它从一堆元素中取一个并做点事情后，把余下的重新交给这个函数。</p><p>再者就是边界条件：一般而言，处理 List 时的边界大部分都是空 List；而处理 Tree 时的边界条件就是没有子元素的节点；处理数字的时候也很一致，一般是寻找幺元作为边界条件。</p><h2 id="高阶函数"><a href="#高阶函数" aria-hidden="true" class="header-anchor">#</a> 高阶函数</h2><p>curry 柯里化</p><p>Haskell 所有多参数的函数都是 curried function。</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> max 4 5
5
ghci<span class="token operator">&gt;</span> <span class="token punctuation">(</span>max 4<span class="token punctuation">)</span> 5
5
</code></pre></div><p>以上两者是等价的。我们看一下 max 的类型：</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :t max
max :: Ord a <span class="token operator">=</span><span class="token operator">&gt;</span> a -<span class="token operator">&gt;</span> a -<span class="token operator">&gt;</span> a
</code></pre></div><p>实际上也可以写作：<code>max :: Ord a =&gt; a -&gt; (a -&gt; a)</code></p><p>中缀函数也可以使用 curry。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">divideByTen</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Floating</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">divideByTen</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span>
</code></pre></div><p>将函数作为参数传递</p><p>比如下面这个例子：</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">applyTwice</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">applyTwice</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code></pre></div><p>注意类型，括号里的表明：首个参数是个类型和返回值都为 a 的函数。</p><p>再来看一个函数。<code>flip</code> 只是简单地将函数的两个参数颠倒一下。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">flip</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span>
<span class="token builtin">flip</span>' <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">g</span>
    <span class="token keyword">where</span> <span class="token hvariable">g</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">y</span> <span class="token hvariable">x</span>
</code></pre></div><p>由于函数默认都是柯里化的，<code>-&gt;</code> 是右结合，所以第二对括号是没有必要的(范畴论)。因此可以改成更为简单的写法。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">flip</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span>
<span class="token builtin">flip</span>' <span class="token hvariable">f</span> <span class="token hvariable">y</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span>
</code></pre></div><p>map 和 filter</p><p>map 的定义：</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>
<span class="token builtin">map</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span>
</code></pre></div><p>最终你会发现，map 完全可以用 List Comprehension 取代。<code>map (+3) [1,2]</code> 和 <code>[x+3 | x &lt;- [1, 2]]</code> 等价。</p><p>filter 的定义：</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">filter</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">filter</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">filter</span> <span class="token hvariable">p</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">p</span> <span class="token hvariable">x</span>       <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">filter</span> <span class="token hvariable">p</span> <span class="token hvariable">xs</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token builtin">filter</span> <span class="token hvariable">p</span> <span class="token hvariable">xs</span>
</code></pre></div><p>同理，filter 也可以用 List Comprehension 的限制条件来做。</p><p><code>filter</code> 和 <code>map</code> 都是惰性的。</p><p>举个例子：找到所有小于 10000 且为奇数的平方的和。我们这么写：</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token function">sum</span> <span class="token punctuation">(</span>takeWhile <span class="token punctuation">(</span><span class="token operator">&lt;</span>10000<span class="token punctuation">)</span> <span class="token punctuation">(</span>filter odd <span class="token punctuation">(</span>map <span class="token punctuation">(</span>^2<span class="token punctuation">)</span> <span class="token punctuation">[</span>1<span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">))</span><span class="token punctuation">)</span>
166650
</code></pre></div><p>如果 <code>map</code> 不是惰性的，恐怕我们的程序就得宕机了。</p><p>lambda</p><p>lambda 就是匿名函数。有时候我们需要传给高端函数一个只会使用一次的函数，就可以搞一个特定功能的 lambda。形式是：</p><div class="language- extra-class"><pre class="language-text"><code>(\ 空号分隔的参数 -&gt; 函数行为)
</code></pre></div><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">numLongChains</span> <span class="token operator">::</span> <span class="token constant">Int</span>
<span class="token hvariable">numLongChains</span> <span class="token operator">=</span> <span class="token builtin">length</span> <span class="token punctuation">(</span><span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token builtin">length</span> <span class="token hvariable">xs</span> <span class="token operator">&gt;</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token hvariable">chain</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>lambda 是个表达式，因此我们可以任意传递。表达式 <code>(filter (\xs -&gt; length xs &gt; 15)</code> 返回一个函数，判断 List 的长度是否大于 15。</p><p>关键字 fold</p><p>回到最初学习递归的情景，有一个处理 List 的模式非常常见：将边界条件设为空 List，再引入 <code>(x:xs)</code> 模式，对单个元素和余下的 List 做些事情。</p><p>Haskell 引入一组函数来使之简化，也就是 fold (类似于 javascript 中的 reduce)。</p><ul><li>foldl - 左折叠</li><li>foldr - 右折叠</li></ul><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">sum</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">sum</span>' <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">acc</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">acc</span> <span class="token operator">+</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token number">0</span> <span class="token hvariable">xs</span>
</code></pre></div><p>初始值为 0。</p><p>考虑到柯里化，即 <code>sum()([1,2,3])</code>，我们还可以简化：</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">sum</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">sum</span>' <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre></div><ul><li><p>foldl1 - 和 foldl 类似，只是无需明确提供初始值，假定 List 的首个元素作为起始值</p></li><li><p>foldr1 - 和 foldr 类似，只是无需明确提供初始值，假定 List 的末尾元素作为起始值</p></li><li><p>scanl 和 scanr 和 foldl 和 foldr 相似，只是它们会记录下累加值的所有状态到一个 List。</p></li><li><p>同理也有 scanl1 和 scanr1</p></li></ul><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> scanl <span class="token punctuation">(</span>+<span class="token punctuation">)</span> 0 <span class="token punctuation">[</span>3,5,2,1<span class="token punctuation">]</span>
</code></pre></div><p>有 $ 函数的函数调用</p><p>定义如下：</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token punctuation">(</span><span class="token operator">$</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
<span class="token hvariable">f</span> <span class="token operator">$</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span>
</code></pre></div><p>也就是说，<code>$</code> 的优先级最低。作用是：用空格调用的函数调用符是左结合的，比如 f a b c 和 ((f a) b) c 等价，而 <code>$</code> 是右结合的。</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> sqrt 3 + 4 + 9
14.732050807568877

ghci<span class="token operator">&gt;</span> sqrt $ 3 + 4 + 9
4.0
</code></pre></div><p>函数组合</p><p>函数组合的定义如下：</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span>
<span class="token hvariable">f</span><span class="token operator"> . </span><span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code></pre></div><p>第一个用户就是生成新函数，并传递给其他函数。</p><p>比如，我们想要将一组数字组成的 List 全部转换为 负数。即元素取绝对值，再取负数。我们用 map 完成。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">negate</span><span class="token punctuation">(</span><span class="token builtin">abs</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
</code></pre></div><p>如果我们用函数组合。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">negate</span><span class="token operator"> . </span><span class="token builtin">abs</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span>
</code></pre></div><p>明白了吗。函数组合与 map 和 lamdma 何其相似。还要一点要注意：函数组合是右结合的。</p><p>如果有多个参数怎么办呢？</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">5</span> <span class="token punctuation">(</span><span class="token builtin">max</span> <span class="token number">6.7</span> <span class="token number">8.9</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>可以重写为 <code>(sum . replicate 5 . max 6.7) 8.9</code> 或 <code>sum . replicate 5 . max 6.7 $ 8.9</code>。</p><p>函数组合的另一个用处是定义 point free style (也称作 pointless style) 的函数。</p><h2 id="module-系统"><a href="#module-系统" aria-hidden="true" class="header-anchor">#</a> module 系统</h2><p>Haskell 中的模块是含有一组相关的函数，类型和类型类的组合。<code>Prelude</code> 就是模块。</p><p>装载和创建模块分别是通过 import 和 module 来实现的。</p><p>比如，装载 Data.List 模块。这个模块里的 <code>nub</code> 函数就可以使用了。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token import_statement"><span class="token keyword">import</span> Data.List</span>

<span class="token hvariable">numUniques</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">numUniques</span> <span class="token operator">=</span> <span class="token builtin">length</span><span class="token operator"> . </span><span class="token hvariable">nub</span>
</code></pre></div><p>或只装载模块的某几个函数。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token import_statement"><span class="token keyword">import</span> Data.List</span> <span class="token punctuation">(</span><span class="token hvariable">nub</span>，<span class="token builtin">sort</span><span class="token punctuation">)</span>
</code></pre></div><p>也可以装载除某个函数之外的其他函数，这可以避免命名冲突。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token import_statement"><span class="token keyword">import</span> Data.List <span class="token keyword">hiding</span></span> <span class="token punctuation">(</span><span class="token hvariable">nub</span><span class="token punctuation">)</span>
</code></pre></div><p>还有一种命名冲突是这样的，比如在 Data.map 模块中，里面有几个和 Prelude 模块同名的函数，比如 filter 和 null。解决方式是引入 <code>qualified import</code>。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token import_statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data.Map <span class="token keyword">as</span> M</span>
</code></pre></div><p>这就是说，当我们要引用 Data.Map 模块中的 filter 函数时，需要是 <code>Data.Map.filter</code>。或者取个别名 M，<code>M.filter</code>。</p><p><a href="https://www.haskell.org/hoogle/" target="_blank" rel="noopener noreferrer">Hoogle<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><p>创建自己的模块</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">module</span> <span class="token constant">Geometry</span>
<span class="token punctuation">(</span> <span class="token hvariable">sphereVolume</span>
<span class="token punctuation">)</span> <span class="token keyword">where</span>

<span class="token hvariable">sphereVolume</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">sphereVolume</span> <span class="token hvariable">radius</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">4.0</span> <span class="token operator">/</span> <span class="token number">3.0</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token hvariable">radius</span> <span class="token operator">^</span> <span class="token number">3</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="自己的-type-和-typeclass"><a href="#自己的-type-和-typeclass" aria-hidden="true" class="header-anchor">#</a> 自己的 Type 和 Typeclass</h2><p>可以看一下 Haskell Bool 的定义。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Bool</span> <span class="token operator">=</span> <span class="token constant">False</span> <span class="token operator">|</span> <span class="token constant">True</span>
</code></pre></div><ul><li>data - 表明要定义一个新类型</li><li>Bool(= 的左边) - type constructor</li><li>= 右边 - value constructor</li></ul><p>类型名和 value constructor 都需要大写。</p><p>假设我们要定义个 Shape。假定是个圆或者长方形。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Shape</span> <span class="token operator">=</span> <span class="token constant">Circle</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token operator">|</span> <span class="token constant">Rectangle</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span>
</code></pre></div><p>所以，value constructor 本质是个函数。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Circle</span>
<span class="token constant">Circle</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Shape</span>
</code></pre></div><p>用自定义的类型来写一个函数，求表面积。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">surface</span> <span class="token operator">::</span> <span class="token constant">Shape</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Circle</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">^</span> <span class="token number">2</span>
<span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Rectangle</span> <span class="token hvariable">x1</span> <span class="token hvariable">y1</span> <span class="token hvariable">x2</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token operator">$</span> <span class="token hvariable">x2</span> <span class="token operator">-</span> <span class="token hvariable">x1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token operator">$</span> <span class="token hvariable">y2</span> <span class="token operator">-</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>第一点：Shape 是类型，Circle 并非类型</li><li>第二点：模式匹配我们针对的都是 value constructor，之前我们匹配的 True, 5, [] 都是无参数的 value constructor。</li></ul><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Shape</span> <span class="token operator">=</span> <span class="token constant">Circle</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token operator">|</span> <span class="token constant">Rectangle</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code></pre></div><p>有了 deriving 关键字，该 Shape 就属于 Show typeclass 中了。调用 <code>Circle 10 20 5</code> 就不会出错。</p><p>Recode syntax</p><p>现在我们来描述一个人，有姓名、年龄、身高、电话号码和爱吃的冰淇淋。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token constant">String</span> <span class="token constant">Int</span> <span class="token constant">Float</span> <span class="token constant">String</span> <span class="token constant">String</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code></pre></div><p>造个人：</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> Person <span class="token string">&quot;xiaoke&quot;</span> 18 178.4 <span class="token string">&quot;130****3790&quot;</span> <span class="token string">&quot;Chocolate&quot;</span>
</code></pre></div><p>其实我们有更好的方式。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span> <span class="token hvariable">name</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">::</span> <span class="token constant">Int</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">height</span> <span class="token operator">::</span> <span class="token constant">Float</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">phoneNumber</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">flavor</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :t name
name :: Person -<span class="token operator">&gt;</span> String
</code></pre></div><ul><li>有了 {} 号</li><li>name、age、height 等都是函数</li><li>这就是 Recode syntax</li></ul><p>Type parameters</p><p>上面提到的都是 value constructor，没错就是 value：value constructor 取几个参数，然后产生(返回) 一个新 value。</p><p>type constructor，取类型作为参数，产生新类型。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Nothing</span> <span class="token operator">|</span> <span class="token constant">Just</span> <span class="token hvariable">a</span>
</code></pre></div><ul><li>Maybe 是 type constructor。有点类似于 泛型，对具体的类型一无所知</li><li>a 是类型参数</li><li>把 Char 交给 May，就可以得到一个 Maybe Char 的类型。Just 'a' 的类型就是 Maybe Char。</li></ul><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :t Just 84
Just 84 :: <span class="token punctuation">(</span>Num t<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> Maybe t

ghci<span class="token operator">&gt;</span> :t Nothing
Nothing :: Maybe a
</code></pre></div><p>Instance</p><p>(不要和传统 OOP 概念中类的实例混淆)。Int 类型就是 Eq 类型类中色一个实例。</p><p>比如我们想要对 <em>相同的人</em> 进行比较：我们就可以直接 driving (Eq)，之后就可以用 == 或 /= 来判断它们是否相等了。否则，就需要自己写函数去来判断。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span> <span class="token hvariable">name</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">::</span> <span class="token constant">Int</span>
                     <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">)</span>
</code></pre></div><p>测试一下：</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token keyword">let</span> xiaoke1 <span class="token operator">=</span> Person<span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;xiaoke&quot;</span>, age <span class="token operator">=</span> 18<span class="token punctuation">)</span>
ghci<span class="token operator">&gt;</span> <span class="token keyword">let</span> xiaoke2 <span class="token operator">=</span> Person<span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;xiaoke&quot;</span>, age <span class="token operator">=</span> 18<span class="token punctuation">)</span>
ghci<span class="token operator">&gt;</span> xiaoke1 <span class="token operator">==</span> xiaoke2
True
</code></pre></div><p>同理，Person 也可以将其应用到所有在类型声明中用到了 Eq 类约束的函数，比如 elem。</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token keyword">let</span> boys <span class="token operator">=</span> <span class="token punctuation">[</span>xiaoke1, xiaoke2<span class="token punctuation">]</span>
ghci<span class="token operator">&gt;</span> xiaoke1 <span class="token variable"><span class="token variable">`</span>elem<span class="token variable">`</span></span> boys
True
</code></pre></div><p>Type synonyms</p><p>在写类型名的时候，[Char] 和 String 等价，可以互换。这就是类型别名 - 就是个不用的名字而已。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">type</span> <span class="token constant">String</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
</code></pre></div><p>类型别名也可以有参数。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">type</span> <span class="token constant">AssocList</span> <span class="token hvariable">k</span> <span class="token hvariable">v</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span> <span class="token hvariable">v</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre></div><p>创建 Typeclasss</p><p>Typeclass 的目的之一就是抽象化操作。比如，如果我们 Person 类型不 driving (Eq)，就需要自己写函数来实现相等性。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span> <span class="token hvariable">name</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">::</span> <span class="token constant">Int</span>
                     <span class="token punctuation">}</span>
<span class="token hvariable">eqPerson</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token operator">...</span>
</code></pre></div><p>这样我们倒不如定义个 Typeclass。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">class</span> <span class="token constant">Eq</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
    <span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token punctuation">(</span><span class="token operator">/=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">/=</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
    <span class="token hvariable">x</span> <span class="token operator">/=</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>a 是类型变量，是任何我们在定义 instance 时的类型，也不一定要叫 a</li></ul><p>然后，我们打算手动(而不是通过 driving (Eq) 的方式)创建一个 Instance。定义类型如下：</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Color</span> <span class="token operator">=</span> <span class="token constant">Red</span> <span class="token operator">|</span> <span class="token constant">Yellow</span> <span class="token operator">|</span> <span class="token constant">Green</span>
<span class="token keyword">instance</span> <span class="token constant">Eq</span> <span class="token constant">Color</span> <span class="token keyword">where</span>
    <span class="token constant">Red</span> <span class="token operator">==</span> <span class="token constant">Red</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token constant">Green</span> <span class="token operator">==</span> <span class="token constant">Green</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token constant">Yellow</span> <span class="token operator">==</span> <span class="token constant">Yellow</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token hvariable">_</span> <span class="token operator">==</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">False</span>
</code></pre></div><ul><li>instance Eq 即表示 Eq 的实例</li><li>a 被替换成具体类型 Color</li><li>由于 == 是用 /= 来定义的，同样的 /= 也是用 == 来定义。所以我们只需要在 instance 定义中复写其中一个就好了</li><li>这叫 minimal complete definition</li></ul><p>定义 typeclass 的 subclass</p><p>比如：</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">class</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Num</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
<span class="token operator">...</span>
</code></pre></div><ul><li>subclass 的实质是添加 class constraints</li><li>这里，是为 <code>class Num a where</code> 中类型变量 a 添加的限制：在某个类型可以被视作 Number 之前，必须先能被比较相不相等</li></ul><p>Maybe 怎么办呢。特别之处在于它是一个 type constructor。单 Maybe a 是一个确切地类型。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token constant">Eq</span> <span class="token punctuation">(</span><span class="token constant">Maybe</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token constant">Just</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token constant">Just</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span>
    <span class="token constant">Nothing</span> <span class="token operator">==</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token hvariable">_</span> <span class="token operator">==</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">False</span>
</code></pre></div><p>不过仍然有个问题，是我们无法保证 Maybe 里面装的可以进行 Eq，所以需要加上限制。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Eq</span> <span class="token punctuation">(</span><span class="token constant">Maybe</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token constant">Just</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token constant">Just</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span>
    <span class="token constant">Nothing</span> <span class="token operator">==</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token hvariable">_</span> <span class="token operator">==</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">False</span>
</code></pre></div><p>最后一件事，如果你想看看一个 typeclass 定义了哪些 instance。<code>:info</code> 也可以查找类型和 type constructor 的信息。</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :info Num

ghci<span class="token operator">&gt;</span> :info Maybe
</code></pre></div><p>yes-no typeclass</p><p>这一个 typeclass 是一个这样的来历：对于 JavaScript 这类弱类型的语言而言，<code>''</code>、<code>false</code>、<code>0</code> 这一类都称为 “假值”，yes-no typeclass 就是模拟这样行为的。</p><p>先声明一个 typeclass。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">class</span> <span class="token constant">YesNo</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
</code></pre></div><p>接下来定义一些 instance。</p><p>数字。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token constant">Int</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token constant">False</span>
    <span class="token hvariable">yesno</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">True</span>
</code></pre></div><p>布尔。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token constant">Bool</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token operator">=</span> <span class="token builtin">id</span>
</code></pre></div><p>让 Maybe 也称为 YesNo 的 Instance</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token punctuation">(</span><span class="token constant">May</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token hvariable">yesno</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">False</span>
</code></pre></div><p>Functor typeclass</p><p>Functor typeclass 基本上可以代表可以被 map 的东西。比如 List，是的，List 就属于 Functor typeclass。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code></pre></div><p>和之前的稍微有点不一样。之前的 a 是一个类型变量，但我们知道这肯定是个确认的类型。<code>f</code> 是一个 type constructor，是接收一个类型的函数。</p><ul><li>fmap 接收一个函数，这个函数从一个类型映射到另一个类型；还接收一个被 functor 应用过的类型；返回一个被 functor 应用过另一个类型。</li></ul><p>我们来看一下针对 List 实现的 map。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token operator">=</span> <span class="token builtin">map</span>
</code></pre></div><ul><li>[] 不能是 [a]，后者是具体的类型；[] 是 type constructor，能构造出 [Int]、[String] 等具体类型</li></ul><p><strong>可以当成盒子的类型可能就是一个 functor</strong>。比如 <code>[]</code> type constructor，就能想象成拥有无限小隔间的盒子：可能全部都是空的；可能部分空；</p><p>比如 Maybe type constructor，也可以表现得像个盒子。可能什么都没有，就是 Nothing；或者装了个东西。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code></pre></div><p>Kind - 类型的类型</p><p>类似于 <code>3</code>、<code>&quot;YEAH&quot;</code>、<code>True</code>(函数也是值的一种) 都有自己的类型。类型就是一个标签。但类型也有自己的标签，也就是类型的类型，就是 kind。<code>:k</code> 可以得知一个类型的 kind。</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :k Int
Int :: *
</code></pre></div><ul><li>就是 Int 类型是 *，表示这个类型是一个具体的类型</li><li>一个具体类型没有任何类型参数，<strong>而值只能属于具体类型</strong>。</li></ul><p>Maybe 就不一样了。</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :k Maybe
May :: * -<span class="token operator">&gt;</span> *
</code></pre></div><ul><li>就是说 Maybe 是类型构造子，接收一个具体类型，然后回传一个具体类型。</li></ul><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :k Maybe Int
May Int :: *
</code></pre></div><p>那 Either 呢。</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :k Either
Either :: * -<span class="token operator">&gt;</span> * -<span class="token operator">&gt;</span> *
</code></pre></div><p>这告诉我们 Either 接受两个具体类型作为参数，并构造出一个具体类型。他看起来也像是一个接受两个参数并回传值的函数类型。类型构造子是可以做 curry 的，所以我们也能 partially apply。</p><h2 id="io"><a href="#io" aria-hidden="true" class="header-anchor">#</a> IO</h2><p>和输入输出设备交互是一个不纯的操作。</p><p>Hello World</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token comment">-- file: helloworld.hs</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token string">&quot;Hello World&quot;</span>
</code></pre></div><p>编译这个程序的方式，有很多。其中一种是：</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ runghc helloworld.hs
</code></pre></div><p>还可以不使用 REPL，直接在终端运行。</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ ghc --make helloworld
$ ./helloworld
Hello World
</code></pre></div><p>复杂一点的例子</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token builtin">putStrLn</span> <span class="token string">&quot;Hello, what's your name?&quot;</span>
    <span class="token hvariable">name</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token string">&quot;Hey &quot;</span> <span class="token operator">++</span> <span class="token hvariable">name</span> <span class="token operator">++</span> <span class="token string">&quot;, you rock!&quot;</span><span class="token punctuation">)</span>
</code></pre></div><p>看一下各自的形态吧。</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :t main
main :: IO <span class="token punctuation">(</span><span class="token punctuation">)</span>

ghci<span class="token operator">&gt;</span> :t putStrLn
putStrLn :: String -<span class="token operator">&gt;</span> IO <span class="token punctuation">(</span><span class="token punctuation">)</span>

ghci<span class="token operator">&gt;</span> :t putStrLn <span class="token string">&quot;Hello World&quot;</span>
putStrLn <span class="token string">&quot;Hello World&quot;</span> :: IO <span class="token punctuation">(</span><span class="token punctuation">)</span>

ghci<span class="token operator">&gt;</span> :type getLine
getLine :: IO String
</code></pre></div><ul><li>putStrLn 接收一个 String，返回一个 IO ()。IO something 类型的所有东西都是一个 IO Action，你可以保存它但是什么都不会发生。</li><li>() 是一个空的 tuple(或叫 unit 型态)。表明从 putStrLn 没有返回值</li><li>IO action 都是有副作用的</li><li>需要理解的是，你在 I/O Action 中运行 I/O Action，并且在那儿调用纯的（非I/O）函数。就是说，IO Action 可以保存一个什么东西，但什么都不会发生。只能有其他 IO Action 运行它。</li><li>也就是 main。它就是那个顶层 IO action。do 才会运行我们 main 这个 IO action。</li><li>getLine 看上去就是保存了 IO action，当这个动作运行时会得到一个 String。</li><li>这样 pure 和 非 pure 的函数就隔离了。</li><li>只有当你有多于一个动作需要运行的时候才要用到 do。do 代码块的值是最后一个动作执行的结果，而且最后一个 IO action 不能绑定任何名字。</li></ul><p>看一个更复杂一点的例子：</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">line</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token keyword">if</span> <span class="token builtin">null</span> <span class="token hvariable">line</span>
        <span class="token keyword">then</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span> <span class="token keyword">do</span>
            <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token hvariable">reverseWords</span> <span class="token hvariable">line</span>
            <span class="token hvariable">main</span>

<span class="token hvariable">reverseWords</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">reverseWords</span> <span class="token operator">=</span> <span class="token builtin">unwords</span><span class="token operator"> . </span><span class="token builtin">map</span><span class="token operator"> . </span><span class="token builtin">reverse</span><span class="token punctuation">.</span> <span class="token builtin">words</span>
</code></pre></div><ul><li>if 在一个 I/O do block 块中，类似于是这样 <code>if condition then IO action else IO action</code></li><li>所以 return () 是一个 IO action。return 在 haskell 中完全不一样：意义是使用某个 pure value 造出一个 IO action。<code>return 'HA'</code> 的类型就是 IO String。通常，可以用 return () 来造出一个没有做任何事情的 IO action</li><li>在 else 中，由于我们递归地调用了 main(还记得吗，main 也是一个 IO action)。因此需要用到 do。</li></ul><p>模块 Control.Monad</p><p>模块 Control.Monad 提供了一些能够处理 IO action 的函数。</p><ul><li>when - 用在 do block 中，接受一个 Boolean 值和 IO action。用法是将 <code>if something then do some I/O action else return ()</code> 这样的模式封装起来。</li><li>forever - 接受一个 IO action 并回传一个永远作同一件事的 IO action。</li></ul><p>文件和字符流</p><p>比如我们有一个文件 baby.txt</p><div class="language-text extra-class"><pre class="language-text"><code>I'm a xiaoke
I'm handsome
haaaaaaaaaaa
</code></pre></div><p>我们如何处理这个文件呢。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token import_statement"><span class="token keyword">import</span> Data.Char</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token builtin">getContents</span>
    <span class="token builtin">putStr</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span>
</code></pre></div><p>编译文件，然后</p><div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">cat</span> baby.txt <span class="token operator">|</span> .toUpperCase
</code></pre></div><p>有一点：</p><ul><li>getContents 是 Lazy IO</li><li><code>foo &lt;- getContents</code> 并不会马上读取所有输入，将他们存在 memory 里面</li></ul><h2 id="functor"><a href="#functor" aria-hidden="true" class="header-anchor">#</a> Functor</h2><p>在 haskell 中，Functor 是一元 type constructor。 属于 Functor typeclass 的 instance，并且满足 functor law。</p><p>提到的 Maybe、[]、Either a 都是 functor。</p><p>其次，IO action 也是 functor。</p><p>Applicative functors</p><p>当我们对 functor map over 一个函数时，用的函数都只接受一个参数。但如果函数接受两个参数呢。</p><p>比如 <code>fmap(*) (Just 3)</code> 的结果是 <code>Just(* 3)</code>，得到了一个包在 Just 中的函数。</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> :t fmap <span class="token punctuation">(</span>++<span class="token punctuation">)</span> <span class="token punctuation">(</span>Just 5<span class="token punctuation">)</span>
fmap <span class="token punctuation">(</span>++<span class="token punctuation">)</span> <span class="token punctuation">(</span>Just 5<span class="token punctuation">)</span> :: Num <span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">&gt;</span> Maybe <span class="token punctuation">(</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> -<span class="token operator">&gt;</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>之后，我们需要用一个能 “吃” (这个包在 Just 中的函数) 的函数来 map over 这个 functor。</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> <span class="token keyword">let</span> a <span class="token operator">=</span> fmap <span class="token punctuation">(</span>*<span class="token punctuation">)</span> <span class="token punctuation">[</span>1,2,3,4<span class="token punctuation">]</span>
ghci<span class="token operator">&gt;</span> fmap <span class="token punctuation">(</span>\f -<span class="token operator">&gt;</span> f 9<span class="token punctuation">)</span> a
<span class="token punctuation">[</span>9,18,27,36<span class="token punctuation">]</span>
</code></pre></div><p>applicative functors 在 Haskell 中是用在 Control.Applicative 中的 Applicative 这个 typeclass 来定义的。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">class</span> <span class="token punctuation">(</span><span class="token constant">Functor</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Applicative</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>
    <span class="token hvariable">pure</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span>
    <span class="token punctuation">(</span><span class="token operator">&lt;*&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code></pre></div><ul><li>class contraint 描述了一个 type constructor 是 Applicative，也必须是 Functor。</li><li>第一个定义是 pure，类型是 <code>pure :: a -&gt; f a</code>。应该要接受一个值，然后回传一个包含那个值的 applicative functor。</li><li><code>&lt;*&gt;</code> 的类型 <code>f (a -&gt; b) -&gt; f a -&gt; f b</code>。<code>&lt;*&gt;</code> 则是接受一个装有函数的 functor 跟另一个 functor，然后取出第一个 functor 中的函数将它对第二个 functor 中的值做 map。</li></ul><p>我们可以看一下 Maybe 的 Applicative 的实现。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token constant">Applicative</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span>
    <span class="token hvariable">pure</span> <span class="token operator">=</span> <span class="token constant">Just</span>
    <span class="token constant">Nothing</span> <span class="token operator">&lt;*&gt;</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
    <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token hvariable">something</span> <span class="token operator">=</span> <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">something</span>
</code></pre></div><p>关键字 newtype</p><h2 id="monad"><a href="#monad" aria-hidden="true" class="header-anchor">#</a> monad</h2><p>当我们谈到 Functor，抽象概念是代表一种可以被 map over 的值。</p><p>Applicative Functor 代表一种带有 context 的型态，可以用函数操作它而且同时保有他的 context。</p><p>Monad 是一个从 Applicative Functor 演进的过程：如果你有一个具有 context 的值 m a，如果把他丢进一个只接受普通值 a 的函数中，并回传一个具有 context 的值。如：</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token punctuation">(</span><span class="token operator">&gt;&gt;=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
</code></pre></div><ul><li>接受一个 monadic value，以及一个接受普通值得函数，然后回传一个 monadic value</li></ul><p>Maybe Monad</p><p>一个 Maybe a 的类型表明 a 的值具备一个可能造成错误的的 context。而 Just &quot;dharma&quot; 的值代表他不是一个 &quot;dharma&quot; 的字符串就是字符串不见时的 Nothing。如果你把字符串当作计算的结果，Nothing 就代表计算失败了。</p><p>Monad type class</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">class</span> <span class="token constant">Monad</span> <span class="token hvariable">m</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>

    <span class="token punctuation">(</span><span class="token operator">&gt;&gt;=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>

    <span class="token punctuation">(</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
    <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token hvariable">y</span>

    <span class="token builtin">fail</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
    <span class="token builtin">fail</span> <span class="token hvariable">msg</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token hvariable">msg</span>
</code></pre></div><ul><li>return 等价于 pure，接受一个普通值并放进一个最小的 context 里。</li><li><code>&gt;&gt;==</code> bind 函数，接受一个 monadic value(具有 context 的值)，并且把他喂给一个接受普通值的函数，并回传一个 monadic value。</li></ul><p>看一下 Maybe 的 Monad instance。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token constant">Monad</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">x</span>
    <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
    <span class="token constant">Just</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span>  <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span>
    <span class="token builtin">fail</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code></pre></div><h2 id="monoids"><a href="#monoids" aria-hidden="true" class="header-anchor">#</a> Monoids</h2><p>Monoids (幺半群)</p><p>我们来看一些操作：</p><div class="language-bash extra-class"><pre class="language-bash"><code>ghci<span class="token operator">&gt;</span> 4 * 1
4
ghci<span class="token operator">&gt;</span> 1 * 9
9
ghci<span class="token operator">&gt;</span> <span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span> ++ <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span>1,2,3<span class="token punctuation">]</span>
ghci<span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> ++ <span class="token punctuation">[</span>0.5, 2.5<span class="token punctuation">]</span>
<span class="token punctuation">[</span>0.5,2.5<span class="token punctuation">]</span>
</code></pre></div><ul><li>函数接受两个参数</li><li>参数和返回值是同样的类型</li><li>存在某些值，使用二元函数时不会改变其他值</li></ul><p>在 haskell 中，monoid 的 typeclass 定义如下：</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">class</span> <span class="token constant">Monoid</span> <span class="token hvariable">m</span> <span class="token keyword">where</span>
    <span class="token hvariable">mempty</span> <span class="token operator">::</span> <span class="token hvariable">m</span>
    <span class="token hvariable">mappend</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span>
    <span class="token hvariable">mconcat</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">m</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span>
    <span class="token hvariable">mconcat</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token hvariable">mappend</span> <span class="token hvariable">mempty</span>
</code></pre></div><p>Lists 是 monoid - 空的 List 可以看成是 identity element。</p><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token constant">Monoid</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token hvariable">mempty</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token hvariable">mappend</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span>
</code></pre></div></div><div class="page-edit"><div class="edit-link"><a href="https://github.com/maoxiaoke/xiaokedada/edit/master/ReadingNote/Real-World-Haskell.md" target="_blank" rel="noopener noreferrer">在 Github 上编辑此页</a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div><!----></div><div class="page-nav"><p class="inner"><span class="prev">
        ← <a href="/ReadingNote/The-Clean-Coder.html" class="prev">
          代码整洁之道
        </a></span><!----></p></div></div></div></div>
    <script src="/assets/js/2.f423fd68.js" defer></script><script src="/assets/js/app.843b634b.js" defer></script>
  </body>
</html>
