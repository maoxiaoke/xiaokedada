# 代码整洁之道

TODO:

读完整本书，自己想要继续往下了解的是：

- [ ] 前端单元测试的框架
- [ ] 前端怎么开展 TDD (尤其是三大框架大行其道的时候)

完整的题目是「代码整洁之道 - 程序员的职业素养」。

## 成为专业人士

### 清楚自己要什么

第一个念头是：编程人员并不是*专业人士*。来做一个职业对比，律师，会计人员和证券师。相比之下，后三者会给人以专业的感觉，专业的感觉就是：当我们去询问他们什么时候可以完工，在获得确切的回答之后，就选择信任这种回答。

然而，在 项目经理、产品、测试等的眼里，程序员是天然的 *bug* 制造者。

所以，成为 *专业人士*，会产生别人的信任感，不会天然地认为程序员站在他们的对立面。

但是，*专业人士* 意味着 **责任与义务**。非专业人士放过了程序的一个 bug，导致公司的损失，会自我安慰：“难免要出点儿状况嘛”。但是专业人士，却必须为此负责。

### 上线未经测试的代码是不负责任的

对例行程序未进行测试就交付软件是不责任的。哪怕需要如期交付的产品，未经过测试，就该早点担起责任：“程序还未经测试，不能上线”。

因此，下面两点是重要的。

1. 让 QA 找不出任何问题。

故意发送明知有错误的代码给 QA，这种做法是及其不专业的；发送未经自测的代码的代码给 QA，这种做法是及其不专业的。

2. 要确保戴代码的正常运行

自测，一遍遍地测，翻来覆去、颠三倒四地测试。同时，为了解放我们的时间，必须对代码进行**百分百**的测试覆盖（自动化单元测试）。百分百当然是个理想的比例，但我们必须尽可能地覆盖。

*尽可能* 的解决方法是：设计易于测试的代码，最好是先写测试，再写要测的代码。

3. “无情” 重构

对每个模块，每次检查，都要比上次检查的时候更为简洁；每次阅读代码，都别忘了进行点滴地改善。

大多数的开发人员，认为对上线的代码不断地修改是危险的。但，让软件固定不变才是危险的。如果一直重构代码，等到不得不重构时，你就会发现代码已经 **僵化** 了。

为什么不改修改上下的代码呢，因为怕破坏线上正常运行的代码。为什么有这样的担心呢，因为他们完全没有对代码进行测试。

### “自由时间” 提升自我

留下 **20%** 的时间来提升自我。

其一就是，了解自己的领域。软件领域，一方面，各种观点、实践、技术和工具层出不穷。成为一名专业的开发者，就需要对其中的相当大的一部分有所了解，而且要不断扩展这方面的知识面。

其二，行业飞速发展。但是我们跟 50 年前一样，写着各种 `if...else` 语句。旧的理论和见解并不会全部过时，我们仍需要了解他们，需要知道它的长处和短处（必然是为了解决某些问题而提出来的）。

所以，以下的旧见解是必要的：

+ 设计模式 - GOF 书中的 24 种模式，以及 POSA 书中的多数模式的实战经验
+ 设计原则 - SOLID 设计原则，组件设计原则
+ 方法
+ 实践 - 掌握驱动开发设计，面向对象设计，结构化设计，持续集成等
+ 工作 - UML 图，DFD 图，结构图，Petri 网络图，状态转移图，流程图和决策图

提升编程能力，成为专业人才。要坚持学习、坚持练习；学会合作，结对编程，从彼此身上学到很多东西；辅导新人，传道受业的同时，自己也会从中受益；了解业务领域，满足雇主的要求；最后，要谦逊。

## 学会说“不”

::: tip
能就是能，不能就是不能，不要说 “试试看”。 -- 尤达
:::

### 专业人士要懂得说“不”

专业人士需要敢于说明真相而不屈服权威。假设，有一个急需上线的项目，上司想压缩你的开发时间。而你明明知道这点开发时间并不够，但是你可能会说：

- **“那好吧，我会尽量试试。”**

这相当不专业！为了完成任务，唯一的办法是怎么乱怎么来，顾不上代码的混乱了；而且，有的时候，事情远远要比开始时所说的要复杂的多 - 客户也许会增加新的功能，而你却要想法设法满足。

“试试看”的成本是什么呢？

意味着你要“付出额外的精力”；意味着你在许诺前是期待或确保成功的；意味着压力就要由你自己来抗了...，因此，要勇敢说“不”。

- **“不，这个项目需要 8 或者 9 周，而不是 4 周，那办不到！”。**

没有谁比专业人士更知道需要多少时间了。强调其中的不确定性，并且绝不退让。

## 说“是”

学会说“不”，是一种专业的表现。学会说”是“，同样是专业的表现。你，你自己，始终都能掌控某些事情，也就是说，总有些事是你可以承诺到的。

作出承诺，包含三个步骤：

1. **口头表达**自己将会去做。
2. **心里认真**对待做出的承诺。
3. **真正**付诸行动。

如何表达你的承诺。当承诺做某事时，应当留意自己的用词，因为某些用词透露了我们对待承诺的认真程度。比如，有一些短语和用词会透露“缺乏承诺”的蛛丝马迹。

+ 需要/应当。“我需要减肥”，“有人应当负责去推动这件事”。
+ 希望/但愿。“希望明天我能完成这个任务”，“但愿我有时间做这件事”。
+ 让我们(而不是 让我)。“让我们把这件事做完”，“让我们回头再见”。

作出真正的承诺的诀窍在于，要去搜寻与下列相似的语句： 我将在 ... 之前 ... (我将在周二之前完成这个任务)。这句话的关键在于，*你对自己将会做某件事做了清晰的试试陈述，而且还明确说明了完成期限。指明了做这件事的对象，不是别人，而是你自己。*。

当然，“言必信，行必果”。可万事都不是完美的。之所以没有成功，可能有以下原因。

1. 是因为我依赖第三方的进度

如果最终目标依赖于他人，那么你就应该采取某些措施，接近你的目标。比如，和依赖方坐到一起，彻底理清模块间的依赖关系。

2. 之所以没有成功，是因为我不太确信是否真能完成得了

即使目标无法达成，你仍能全力以赴，离目标更近些。

3. 之所以没有成功，是因为有些时候我真的无能为力

有些事情你先前没有预料到，这很现实。但如果你仍然希望自己能够不负众望，那就赶紧去调整别人对你的预期，**越快越好**！

你越早向各方发起预警信号，整个团队就越有可能抓住机会，终止并重新评估当前的活动，并决定是否应该采取一些措施或作出改变。

如果你不尽早告诉别人可能的问题，就错失了让他们帮你完成目标，兑现诺言的机会。

## 编码

编码是一项颇具挑战也十分累人的智力活动。相比其他类型的活动，编码要求更加聚精会神。

(1) 首先，代码必须正常工作
(2) 其次，代码必须能够解决客户提出的问题
(3) 再次，代码必须能和现有系统结合得天衣无缝 - 即，编写代码必须遵循稳健的过程
(4) 最后，其他程序员必须能够读懂你的代码

如果感到疲劳或心烦意乱，**千万不要编码**。

### 避免进入 “流态区”

“流态” 是一些程序员在编写代码时会进入的一种意识专注但思维视野却会收拢到狭窄的状态；这种状态下，他们会感到效率极高，会感到“绝无错误”。

但 “流态区” 并非真的极为高效，也绝非毫无错误。这其实是一种 “浅层冥想” 状态，在这种状态下，为了追求所谓的速度，理性思考的能力会下降。

当你感觉自己进入 “流态区”，就该走开几分钟或者去找一个结对编程的搭档。

### 音乐对 “编程” 毫无帮助

很多人写代码的时候喜欢戴着耳机。但，真实情况可能是，音乐正带领我们进入 “流态区”。

### 中断

中断无法避免，总有干扰会打断你、消耗你的时间。发生这种情况时要记住一点，也许下次也会轮到你去打断别人请求帮助。因此，礼貌地表现出乐于助人的态度才是专业的态度。

### 帮助他人

要清楚团队伙伴的状态。如果有人看起来遇到了麻烦，就应该向他提供帮助。给他人提供帮助并非说明你比人家聪明很多，而是因为你带了一个新的视角，对于解决问题起到了显著的催化作用。

帮助别人的时候，可以坐下来和他一起写代码，为此需要预留出一个小时甚至更长的时间。

### 接受他人的帮助

如果有人向你伸出援手，要诚挚接受，心怀感激地接受帮助并诚意合作。

要学会如何请求帮助。当你受阻时，或者有点犯晕时，或者只是绕一个问题绕不出去的时候，不防请求别人的帮助。

程序员大多自负、固执、内向。但是为了能够实现高效编程，好的协作至关重要。

## 测试驱动开发 - TDD

定论：

+ TDD 确实可行。
+ 争论已经结束。

### TDD 的三项法则

1. 在编写好失败单元测试之前，不要编写任何产品代码
2. 只要有一个单元测试失败了，就不要再写测试代码了；无法通过编译也是一种失败情况。
3. 产品代码恰好能够让当前失败的单元测试成功通过即可，不要多写。

### TDD 的优势

1. 确定性

当你更改你的代码，然后运行全部的单元测试和验收测试。如果这些测试全部通过，你就可以随时交付。

2. 减少缺陷注入率

TDD 能显著降低缺陷。

3. 勇气

拥有一套值得信赖的测试，便可打消对修改代码的全部恐惧。

4. 文档

单元测试即是文档，它们描述了系统设计的最底层设计细节。它们是最好的底层文档。

5. 松耦合的设计

遵循 TDD 的三步法则，并且测试先行，就会有一种驱动力。促使你作出「松耦合」的设计。

6. 专业

显得专业(或许不该如此来割裂自己，但确实如此)。

## 验收测试

### 需求的沟通

业务方描述他们认为自己需要的东西，程序员按照自己理解的业务方表达的需求来开发。从理论上说，应该是这样，但现实中，关于需求的沟通是将其复杂的。包括：

1. 过早精细化

过早精细化指的是：业务方还没启动项目，就要精确知道最后需要什么；开发方还没有评估整个项目，就希望精确知道要交付什么。

这都是不好的。第一，东西画在纸上和真正做出来，是不一样的。在工作中，有一个现象叫 *观察者效应* 或者 *不确定原则*。当你向业务方展示一项功能，他们就获得了比之前更多的信息，这些新信息反过来又会影响他们对整个系统的看法 - 关于到底要什么，他们会冒出更好的想法，而且通常并不是他们当时看到的样子。

其二，开发人员也会进行精确评估。但是，即便拥有了全面的信息，评估也通常存在巨大变数。需求是 *一定* 会变化的，追求那种精确性是徒劳的。

避免过早精细化的办法是尽可能地推迟精细化，专业的开发人员直到着手开发的前一刻才会把需求具体化。

> 吾语：着手开发的前一刻？应该是拿出具体方案的时候。具体方案当然在开发过程中仍然可以调整，但大致方向应该一致。

2. 迟来的模糊性

解决办法：进行验收测试。

### 验收测试

文中的定义：业务方和开发方合作编写的测试，其目的在于确定需求已经完成。文章不认为这就代表 QA 测试。

1. 完成的定义是什么呢？

文章这么认为：所有的代码都写完了，所有的测试都通过了，QA 和需求方已经认可。

2. 验收测试的目的是什么呢

是沟通、澄清和精细化。确保大家都明白要做的是什么，是自己的责任。

3. 验收测试的方式

验收测试应当自动进行(即自动化的验收测试)。

4. 验收测试什么时候写，由谁来写

理想状态下，业务方和 QA 会写作编写这些测试，程序员来检查测试之间的冲突和矛盾(但，最终会交给业务分析员、QA 甚至是开发人员)。

通常，业务分析员测试 “正确路径”，以证明功能的业务价值；QA 则测试 “错误路径”、边界条件、异常和例外情况。

遵循 “推迟精细化” 原则，验收测试应该越晚越好，通常是功能执行完成的前几天。迭代开始的第一天，就应当准备好最初的几项验收测试。然后每天完成一些验收测试，到迭代的中间点，所有的测试都应该准备完毕。

5. 开发人员的职责

与编写测试的人协商并进行改进测试时你的责任，绝不能被动接受测试。因为很有可能，有些测试没有意义、有些过于复杂、有些包含愚蠢的设定、有些干脆就是错的。

6. 验收测试和单元测试的区别

单元测试是程序员写给程序员的，是正式的设计文档，描述了底层结构及代码的行为。

验收测试是业务方写给业务方的，是正式的需求文档，描述了业务方认为系统应该如何运行。

文中认为，两种测试的根本目的在于测试的 *文档性*，而不是 *测试*。测试只是附加功能，而两者真正描述的是 **系统的设计、结构、行为**。

7. GUI 界面的测试

GUI 很容易变化，测试非常容易出问题。更好的方法是，测试系统功能时，应当调用真实的 API，而不是 GUI。设计专家一直教导我们，*要把 GUI 和业务逻辑分开*。

> 吾语：业务分析员应该指的就是国内产品这个职称。对于验收测试，国内这一块到底是如何做的呢？

### 持续集成

确保代码在持续集成系统中。整套继续集成系统应该由源代码管理系统来触发，只要有人提交了代码，持续集成系统就会开始构建。

保持持续集成系统的时刻运行时非常重要的。持续集成不应该失败，如果失败了，团队里的所有人都应该停下手里的活，看看如何让测试通过。在持续集成系统里，失败的集成应该视为紧急情况，也就是 “立刻中止” 型事件。

## 测试策略

每个专业的开发团队都需要一套好的测试策略(测试策略因团队而异)。

一般的测试策略呈金字塔状。位于顶尖的是 *人工探索式*，塔底的是 *单元测试*。

| type | percent | desc |
| :---: | :---: | :---: |
| 人工探索式测试| ~5% | 人工介入的测试，是确保系统在人工操作下表现良好 |
| 系统测试| ~10% | 针对集成完毕的系统来运行的自动化测试 |
| 集成测试| ~20% | 集成测试对较大型的系统才有意义 |
| 组件测试| ~50% | 是验收测试的一种 ，通常是针对系统的各个组件而编写的 |
| 单元测试| ~100% |  单元测试可以做到接近 100% 的覆盖率 |

## 时间管理

身为专业开发人员，应当在短暂的时间内高效地工作。

1. 会议

会议是必须的；但会议会浪费大量的时间。

受到邀请的会议不必全部参加。参加的会议太多，反而证明自己的不专业。应当礼貌地使用时间，所以必须谨慎选择，应当参加哪些会议，礼貌拒绝哪些会议。

邀请你参加会议的人并不负责管理你的时间，为时间负责的只有你。

哪些会议不用参加呢？务必确保出席会议可以给自己目前的工作带来切实且显著的成效，否则不参与；有些会议你很感兴趣，但当下没有参加的必要，仔细斟酌是否参加；有些会议是关于你已经完成的某些事项的，对目前的工作并没有现实意义，可以选择不参加。

2. 离席

会议并不总按照计划进行。如果你发现参加某个会议是在浪费时间，就应当想个礼貌的办法退出来。

3. 确定议程和目标

会议应该有个清晰的议程，确定每个议题所花的时间，以及明确的目标。

4. 站会

三个问题：

(1) 我昨天干了什么
(2) 我今天打算干什么
(3) 我遇到了什么问题

这应该是站会的全部内容。每个问题的回答时间不应当超过 20 秒。

5. 迭代会议

会议的节奏应该足够快，简明扼要地讨论各个候选任务，然后决定是选择还是放弃。会议在每个任务上所花的时间都应该限制在 5 到 10 分钟。

6. 迭代回顾

这类会议是在迭代的末尾展开。团队成员讨论本轮迭代中什么做得对，什么做得不对。这类会议大概占据 45 分钟即可( 20 分钟回顾，25 分钟来演示)。而且，这类会议只牵涉到最近一两周的工作，所有没有太多的内容要讨论。

7. 争论和反对

「凡是不能在 5 分钟内解决的争论，都不能靠辩论解决」- Kent Beck。

解决争论和反对的措施，便是民主投票，不要过度浪费会议时间。

8. 睡眠

睡眠的重要性怎么强调都不为过。

9. 时间拆分和番茄工作法

番茄工作法也许是管理时间的一个有效办法之一，但前提是，你要时时刻刻坚持。

10. 优先级错乱、死胡同和泥潭

这是三种我们可能陷入的状态。

其一便是优先级错乱。很多时候，我们都可以找到办法来逃避真正的工作；你说服自己有些工作更紧急，所以转去处理，这种行为就叫做 *优先级错乱* - 提高某个人物的优先级，之后有借口推迟真正急迫的任务。优先级错乱是自我麻醉的谎言。专业人士会评估每个任务的优先级，排除个人的喜好和需要，按照真实的紧急程度来执行任务。

其二便是死胡同。比如，选择了一条走不通的技术道路；你越是坚持，浪费的时间就越多。所以真正需要的是，当走入死胡同时可以迅速意识到，并有足够的用去走回头路。这就是所谓的 *坑法则*：「如果你掉进坑里，别挖」。

泥潭是我们格外需要注意的。泥潭会减慢你的速度，但不会让你彻底停下来。而往往处于泥潭中的开发者仍然可以看到前进的道路，还会坚持认为终点比回头路更短(但有时，实际并非如此)。比如，面对简单问题，你给出解决方案，保持代码的简单、整洁。之后问题不断扩展，越来越复杂，你则扩展代码库，尽可能保持整洁。某天，你发现自己从一开始就做了错误的选择，在需求变化的方向上，程序跟不上节奏。这就是转折点，你可以回头修正设计，也可以继续走下去。**走回头路看起来代价很高，因为要把已有的代码推翻重来，但是走回头路绝对是最简单的方法**。

> 吾言：对于 *泥潭*，我觉得可以参考 Node 的开发，在 Node 在设计上的缺陷。陷入泥潭，最终的方式是推翻重来，创建了另一个 deno。

## 预估

预估也许是软件从业者面对的最简单的，也是最可怕的活动之一了。对于预估，业务方觉得是承诺，开发方认为是猜测。

预估应该是一种猜测。预估也不是定数，预估的结果是一种概率分布。

#### PERT 计算方法

PERT(Program Evaluation and Review Technique) 计算方法从三个维度把预估变成概率分布。

+ *O*：乐观预估。这个数字对应的发生概率应当小于 1%。
+ *N*：标称预估。这是概率最大的数字。
+ *P*：悲观预估。这是最糟糕的数字，这个数字的发生概率也应当小于 1%。

那么期望的完成时间，我们用 𝞵 表示。

```
𝞵 = (O + 4N + P) / 6
```

标准差 σ 用来衡量不确定性。

```
σ = (P - O) / 6
```

比如如下任务预估表：

| Task | O | N | P | 𝞵 | σ |
| :---: | :---: | :---: | :---: | :---: | :---: |
| alpha| 1 | 3 | 12 | 4.2 | 1.8 |
| beta | 1 | 1.5 | 14 | 3.5 | 2.2 |
| gamma| 3 | 6.25 | 11 | 6.5 | 1.3 |

所以完成时间应该是 4.2 + 3.5 + 6.5 = 14 天。总的标准差是 1.8<sup>2</sup> + 2.2<sup>2</sup> + 1.3<sup>2</sup> 的开方，为 3.13。

所以，完成时间这些任务的时间是 14 天，最坏的情况是 17 天，最好的情况是 11 天。