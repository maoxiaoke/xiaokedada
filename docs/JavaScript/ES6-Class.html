<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>近似 Class 的操作 | XIAOKEDADA</title>
    <meta name="description" content="Write something useful and funny">
    <link rel="icon" href="/favicon.png">
    
    <link rel="preload" href="/assets/css/68.styles.d3eb3505.css" as="style"><link rel="preload" href="/assets/js/app.843b634b.js" as="script"><link rel="preload" href="/assets/js/28.8aaaacba.js" as="script"><link rel="prefetch" href="/assets/js/35.fc0649b6.js"><link rel="prefetch" href="/assets/js/1.85421567.js"><link rel="prefetch" href="/assets/js/2.f423fd68.js"><link rel="prefetch" href="/assets/js/3.1f142fb1.js"><link rel="prefetch" href="/assets/js/4.bd68aee8.js"><link rel="prefetch" href="/assets/js/5.0a465bdb.js"><link rel="prefetch" href="/assets/js/6.97e629f1.js"><link rel="prefetch" href="/assets/js/7.bb19bdef.js"><link rel="prefetch" href="/assets/js/8.5daef4ca.js"><link rel="prefetch" href="/assets/js/9.4fcb0f34.js"><link rel="prefetch" href="/assets/js/10.4376478b.js"><link rel="prefetch" href="/assets/js/11.8fc6b13a.js"><link rel="prefetch" href="/assets/js/12.1772ec65.js"><link rel="prefetch" href="/assets/js/13.a4ef0e77.js"><link rel="prefetch" href="/assets/js/14.427f03c9.js"><link rel="prefetch" href="/assets/js/15.723a7d06.js"><link rel="prefetch" href="/assets/js/16.166d836c.js"><link rel="prefetch" href="/assets/js/17.21b4f630.js"><link rel="prefetch" href="/assets/js/18.fd756ec4.js"><link rel="prefetch" href="/assets/js/19.a8b80d16.js"><link rel="prefetch" href="/assets/js/20.8e9cdb67.js"><link rel="prefetch" href="/assets/js/21.4e4f2b91.js"><link rel="prefetch" href="/assets/js/22.d28267a3.js"><link rel="prefetch" href="/assets/js/23.653fa423.js"><link rel="prefetch" href="/assets/js/24.8ed99de7.js"><link rel="prefetch" href="/assets/js/25.614045fd.js"><link rel="prefetch" href="/assets/js/26.02791f7a.js"><link rel="prefetch" href="/assets/js/27.3fa3f1e9.js"><link rel="prefetch" href="/assets/js/29.02e1b211.js"><link rel="prefetch" href="/assets/js/30.46e3e02b.js"><link rel="prefetch" href="/assets/js/31.8af56ad3.js"><link rel="prefetch" href="/assets/js/32.091d8ef1.js"><link rel="prefetch" href="/assets/js/33.d33fb871.js"><link rel="prefetch" href="/assets/js/34.d41761e9.js"><link rel="prefetch" href="/assets/js/0.e6be7c2e.js"><link rel="prefetch" href="/assets/js/36.d0053b92.js"><link rel="prefetch" href="/assets/js/37.21574b04.js"><link rel="prefetch" href="/assets/js/38.80e207ae.js"><link rel="prefetch" href="/assets/js/39.e4995ccf.js"><link rel="prefetch" href="/assets/js/40.5d361e67.js"><link rel="prefetch" href="/assets/js/41.a50cd60b.js"><link rel="prefetch" href="/assets/js/42.caf66f0e.js"><link rel="prefetch" href="/assets/js/43.4a9eaf80.js"><link rel="prefetch" href="/assets/js/44.448792e0.js"><link rel="prefetch" href="/assets/js/45.a2c7b618.js"><link rel="prefetch" href="/assets/js/46.d5711dfe.js"><link rel="prefetch" href="/assets/js/47.b7c59a32.js"><link rel="prefetch" href="/assets/js/48.d54390f0.js"><link rel="prefetch" href="/assets/js/49.0e14e323.js"><link rel="prefetch" href="/assets/js/50.116c6f8c.js"><link rel="prefetch" href="/assets/js/51.00a2e7ea.js"><link rel="prefetch" href="/assets/js/52.96b8f0e2.js"><link rel="prefetch" href="/assets/js/53.6316d91b.js"><link rel="prefetch" href="/assets/js/54.3120e195.js"><link rel="prefetch" href="/assets/js/55.7582a732.js"><link rel="prefetch" href="/assets/js/56.eab8bc2a.js"><link rel="prefetch" href="/assets/js/57.74edb44a.js"><link rel="prefetch" href="/assets/js/58.5122e2dc.js"><link rel="prefetch" href="/assets/js/59.3ec0162a.js"><link rel="prefetch" href="/assets/js/60.8ec70531.js"><link rel="prefetch" href="/assets/js/61.fc7a010b.js"><link rel="prefetch" href="/assets/js/62.e17877aa.js"><link rel="prefetch" href="/assets/js/63.44b0382a.js"><link rel="prefetch" href="/assets/js/64.621d7404.js"><link rel="prefetch" href="/assets/js/65.755ec884.js"><link rel="prefetch" href="/assets/js/66.bfb5a72d.js"><link rel="prefetch" href="/assets/js/67.b71bf6f3.js">
    <link rel="stylesheet" href="/assets/css/68.styles.d3eb3505.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      XIAOKEDADA
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/JavaScript/" class="nav-link router-link-active">JavaScript</a></div><div class="nav-item"><a href="/FirstMeet/" class="nav-link">FirstMeet系列</a></div><div class="nav-item"><a href="/CSS/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/ReadingNote/" class="nav-link">读书笔记</a></div><div class="nav-item"><a href="/GatherAll/" class="nav-link">R &amp; T</a></div><a href="https://github.com/maoxiaoke/xiaokedada" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/JavaScript/" class="nav-link router-link-active">JavaScript</a></div><div class="nav-item"><a href="/FirstMeet/" class="nav-link">FirstMeet系列</a></div><div class="nav-item"><a href="/CSS/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/ReadingNote/" class="nav-link">读书笔记</a></div><div class="nav-item"><a href="/GatherAll/" class="nav-link">R &amp; T</a></div><a href="https://github.com/maoxiaoke/xiaokedada" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading"><span>Depth-in-Series</span><!----></p><ul class="sidebar-group-items"><li><a href="/JavaScript/Require-and-Import.html" class="sidebar-link">require 和 import 的难点</a></li><li><a href="/JavaScript/Property-Descriptors.html" class="sidebar-link">JavaScript 对象的 Property descriptors</a></li><li><a href="/JavaScript/Depth-in-ES6.html" class="sidebar-link">深入理解 ES6</a></li><li><a href="/JavaScript/Depth-in-This.html" class="sidebar-link">this 的挑战</a></li><li><a href="/JavaScript/Depth-in-Closure.html" class="sidebar-link">来一次痛痛快快得闭包挑战</a></li><li><a href="/JavaScript/Async-Programming.html" class="sidebar-link">JavaScript 异步编程</a></li><li><a href="/JavaScript/Prototype.html" class="sidebar-link">再谈原型和继承</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading open"><span>Re-learn ES6</span><!----></p><ul class="sidebar-group-items"><li><a href="/JavaScript/ES6-Let-and-Const.html" class="sidebar-link">最佳实践，使用 let/const</a></li><li><a href="/JavaScript/ES6-Class.html" class="active sidebar-link">近似 Class 的操作</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#overview" class="sidebar-link">Overview</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#class-的类型" class="sidebar-link">Class 的类型</a></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#can-t-invoke-via-a-function-call" class="sidebar-link">Can't invoke via a function call</a></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#class-声明存在暂时性死区" class="sidebar-link">Class 声明存在暂时性死区</a></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#this-不能用在-super-之前" class="sidebar-link">this 不能用在 super 之前</a></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#class-内只有方法，没有数据属性" class="sidebar-link">Class 内只有方法，没有数据属性</a></li></ul></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#面向对象编程的理论" class="sidebar-link">面向对象编程的理论</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#实例化" class="sidebar-link">实例化</a></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#构造函数" class="sidebar-link">构造函数</a></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#继承" class="sidebar-link">继承</a></li></ul></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#javascript-面向对象编程理论" class="sidebar-link">JavaScript 面向对象编程理论</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#传统的-class-是复制的，-prototype-是关联的" class="sidebar-link">传统的 Class 是复制的，[[Prototype]] 是关联的</a></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#javascript-的-“class”-和-“继承”-只是一种对象关联" class="sidebar-link">JavaScript 的 “Class” 和 “继承” 只是一种对象关联</a></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#new、constructor、实例等概念隐藏了-prototype-的真实" class="sidebar-link">new、constructor、实例等概念隐藏了 [[Prototype]] 的真实</a></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#me-和-person-prototype-是一种-“委托”-的关联关系" class="sidebar-link">me 和 Person.prototype 是一种 “委托” 的关联关系</a></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#继承-2" class="sidebar-link">继承</a></li></ul></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#es6-class" class="sidebar-link">ES6 Class</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#constructor" class="sidebar-link">constructor</a></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#static" class="sidebar-link">static</a></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#prototype" class="sidebar-link">prototype</a></li></ul></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#es6-class-继承" class="sidebar-link">ES6 Class 继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#子类的-prototype-指向-“父类”" class="sidebar-link">子类的 [[Prototype]] 指向 “父类”</a></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#super" class="sidebar-link">super</a></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#extends" class="sidebar-link">extends</a></li></ul></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#es-next" class="sidebar-link">ES Next</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#proposal-class-fields" class="sidebar-link">proposal-class-fields</a></li></ul></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#其他概念" class="sidebar-link">其他概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#new-target" class="sidebar-link">new.target</a></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#symbol-species" class="sidebar-link">Symbol.species</a></li></ul></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#class-单例模式" class="sidebar-link">Class 单例模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#我们真的需要吗" class="sidebar-link">我们真的需要吗</a></li></ul></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#class-的批评" class="sidebar-link">Class 的批评</a></li><li class="sidebar-sub-header"><a href="/JavaScript/ES6-Class.html#reference" class="sidebar-link">Reference</a></li></ul></li><li><a href="/JavaScript/ES6-Symbols.html" class="sidebar-link">万物皆不同 - Symbols</a></li><li><a href="/JavaScript/ES6-Iterator-And-Iterable.html" class="sidebar-link">迭代协议</a></li><li><a href="/JavaScript/ES6-Async.html" class="sidebar-link">异步编程要点</a></li><li><a href="/JavaScript/ES6-Generator.html" class="sidebar-link">Generator</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Light FP</span><!----></p><ul class="sidebar-group-items"><li><a href="/JavaScript/Light-FP-Overview.html" class="sidebar-link">Light-FP 概念篇</a></li><li><a href="/JavaScript/Light-FP-Categries.html" class="sidebar-link">范畴学基础理论</a></li><li><a href="/JavaScript/Light-FP-Compose.html" class="sidebar-link">Compose</a></li><li><a href="/JavaScript/Light-FP-Container-And-Functor.html" class="sidebar-link">Container and Functor</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>基础内容</span><!----></p><ul class="sidebar-group-items"><li><a href="/JavaScript/AJAX.html" class="sidebar-link">AJAX</a></li><li><a href="/JavaScript/Coercion.html" class="sidebar-link">强制类型转换</a></li><li><a href="/JavaScript/Map-and-Reduce.html" class="sidebar-link">JavaScript 的 map/reduce</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>DOM 相关</span><!----></p><ul class="sidebar-group-items"><li><a href="/JavaScript/DOM-Operation.html" class="sidebar-link">原生JavaScript的DOM操作</a></li><li><a href="/JavaScript/DOM-More.html" class="sidebar-link">再来仔细研究DOM</a></li><li><a href="/JavaScript/DOM-History.html" class="sidebar-link">和 URL 相关的 Location 和 History</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Thinking-in-JavaScript</span><!----></p><ul class="sidebar-group-items"><li><a href="/JavaScript/Small-and-Chunk-Code.html" class="sidebar-link">书写有用而优雅的代码</a></li><li><a href="/JavaScript/I-Dont-Know-JavaScript.html" class="sidebar-link">你看到的 JavaScript，并不是真实的</a></li><li><a href="/JavaScript/Refactor-JavaScript.html" class="sidebar-link">有关代码重构和整洁之道</a></li><li><a href="/JavaScript/JavaScript-Design-Pattern.html" class="sidebar-link">设计模式</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="近似-class-的操作"><a href="#近似-class-的操作" aria-hidden="true" class="header-anchor">#</a> 近似 Class 的操作</h1><p>TODO:</p><ul><li>[ ] this.xxx 要在 super() 之前</li><li>[ ] class 的新提案 1. # 2. 成员函数表达式</li><li>[ ] this/Person/constructor</li><li>[ ] constructor 可以是 static 吗</li></ul><h2 id="overview"><a href="#overview" aria-hidden="true" class="header-anchor">#</a> Overview</h2><p>下面是一个最简单的 class <code>Person</code> 和 derived class <code>Empolyee</code>：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">create</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">this</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">toString</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> title<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title
  <span class="token punctuation">}</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> - </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="class-的类型"><a href="#class-的类型" aria-hidden="true" class="header-anchor">#</a> Class 的类型</h3><p>常说 Class 只是 <em>语法糖</em> 而已，「不是什么大不了的东西」。举证如下：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> Person <span class="token comment">// 'function'</span>
</code></pre></div><blockquote><p>「没什么大不了的东西」似乎看上去是这样，但我往往不敢这么描述。如果某些看上去很简单的东西，How about diging deeper?</p></blockquote><h3 id="can-t-invoke-via-a-function-call"><a href="#can-t-invoke-via-a-function-call" aria-hidden="true" class="header-anchor">#</a> Can't invoke via a function call</h3><p>Class 可以通过 <code>new</code> 关键字进行实例化，但无法直接进行函数调用。也就是说，虽然 <code>typeof Person</code> 的结果是 <code>function</code>，但是我们没有办法像使用函数一样调用它。这是因为 ES6 的函数有一个内部的 <code>[[call]]</code> 状态，在<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist" target="_blank" rel="noopener noreferrer">标准中将 Class 作为函数调用<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>被禁止了(并不意味着以后不会放开这个限制)。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// TypeError: Classes can’t be function-called</span>
</code></pre></div><h3 id="class-声明存在暂时性死区"><a href="#class-声明存在暂时性死区" aria-hidden="true" class="header-anchor">#</a> Class 声明存在暂时性死区</h3><p>也就是说，“Class 声明不会被 hoisted”。有以下原因：</p><ol><li><p>和引入 <code>let</code>、<code>const</code> 保持一致的理论。</p></li><li><p>另外是因为 <code>extends</code> 语句的限制。这个我们会稍后讨论。</p></li></ol><h3 id="this-不能用在-super-之前"><a href="#this-不能用在-super-之前" aria-hidden="true" class="header-anchor">#</a> this 不能用在 super 之前</h3><p>新的提案会改变这种策略。</p><h3 id="class-内只有方法，没有数据属性"><a href="#class-内只有方法，没有数据属性" aria-hidden="true" class="header-anchor">#</a> Class 内只有方法，没有数据属性</h3><p>这样处理的用意在：Prototype 有数据属性被认为是 anti-pattern。因此，所有的数据属性声明都可以放在 <code>constructor</code> 内。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token punctuation">}</span>
  <span class="token function">toString</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="面向对象编程的理论"><a href="#面向对象编程的理论" aria-hidden="true" class="header-anchor">#</a> 面向对象编程的理论</h2><p>什么是 Object Oriented Programming(OOP)？有些人可能会回答：封装(Encapsulation)、继承(Inheritance) 和 多态(Polymorphism)。emmm, that's right. But What does it means?</p><p>Class 描述了一种代码的组织方式，是软件对真实世界的一种建模，即 <strong>对象以及操作对象的行为组装在一起</strong><sup>1</sup>。意思是说，OOP 关注的是对象(数据)的一系列操作<sup>2</sup>，而非逻辑。</p><h3 id="实例化"><a href="#实例化" aria-hidden="true" class="header-anchor">#</a> 实例化</h3><p>Class 只是一个 “蓝图”，是描述一个 <strong>对象应该是什么样子</strong>。而真正进行逻辑操作和交互的数据，需要进行 Class 的 <strong>实例化</strong>。</p><p>Class 的 <em>实例</em>(Instance)，就是 Class 中描述的所有特性的一份 <strong>拷贝</strong>。</p><h3 id="构造函数"><a href="#构造函数" aria-hidden="true" class="header-anchor">#</a> 构造函数</h3><p>凭空实例化一个 Class 是存在于想象中的。Class 的实例需要 <em>构造函数</em>(Constructor) 进行构造，这个方法的任务就是 <em>初始化</em> 实例需要的所有状态。</p><h3 id="继承"><a href="#继承" aria-hidden="true" class="header-anchor">#</a> 继承</h3><p>继承有点类似于基因的遗传 - 父母的基因特性会遗传给孩子。但这并不意味着孩子的特性完全复制父母的特性。<strong>相对于父类来说，子类是一个独立且完全不同的 Class</strong>。子类会包含父类行为的原始副本，但也可以重写所有继承的行为或定义新行为。</p><p>此外，有一点需要强调的是：子类也是 Class，而不是父类的实例。</p><h2 id="javascript-面向对象编程理论"><a href="#javascript-面向对象编程理论" aria-hidden="true" class="header-anchor">#</a> JavaScript 面向对象编程理论</h2><p>可能 <a href="https://brendaneich.com/" target="_blank" rel="noopener noreferrer">Brendan Eich<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 都没想到 JavaScript 面向对象的设计会演变成现在这样。en~~~，我的意思是：<code>[[Prototype]]</code> 或许是实现 OOP(Object Oriented Programming) 的一种方式，但官方(社区)无时无刻不在模仿传统 Class 的 OOP 设计不禁让人诧异。接下来就知道，<code>[[Prototype]]</code> 和 Class 的表现完全不一样！！！</p><h3 id="传统的-class-是复制的，-prototype-是关联的"><a href="#传统的-class-是复制的，-prototype-是关联的" aria-hidden="true" class="header-anchor">#</a> 传统的 Class 是复制的，[[Prototype]] 是关联的</h3><p>在传统的 Class 理论中，Class 和 Instance 是 “蓝图” 和 “建筑” 的关系，多个实例就是多份 Class 所描述的特性的拷贝。从内存的角度而言，Class 声明只是存在于代码段(Text Segment)的一段特性描述代码，只有在实例化的时候才会被动态分配到 Heap 或 Stack。</p><p>但 <code>[[Prototype]]</code> 并不是这样。我们无法创建 “Class” 的多个 “实例”，只能创建多个 “多个对象”。两个对象之间通过 <code>[[Prototype]]</code> 进行关联，实际上我们并没有任何 “拷贝” 操作。</p><h3 id="javascript-的-“class”-和-“继承”-只是一种对象关联"><a href="#javascript-的-“class”-和-“继承”-只是一种对象关联" aria-hidden="true" class="header-anchor">#</a> JavaScript 的 “Class” 和 “继承” 只是一种对象关联</h3><p>在 JavaScript 中描述 “Class” 本身就是个错误的叙述(是的，只有 <code>[[Prototype]]</code>，没有 Class)，所以我添上了 <code>“”</code> 来作为一种注解。</p><p>为什么会这样说？我们来看一个案例(ES5 的方式)：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'xiaoke'</span><span class="token punctuation">)</span>
</code></pre></div><p>我们将分析 <code>me</code>、<code>Person</code> 和 <code>Person.prototype</code> 的关系图。</p><p><img src="https://github.com/maoxiaoke/xiaokedada/blob/master/assets/prototype.png?raw=true" alt></p><p>可以看到， <code>桥接</code> 了 “构造函数” (<code>Person()</code>) 和 “实例” (<code>me</code>) 的实际上是<code>Person.prototype</code>。也就是说，“实例” 和 “构造函数” 之间没有任何 <strong>直接联系</strong> (当然，你完全可以反问到：<code>me</code> 的 <code>constructor</code> 指向了 <code>Person()</code> 呀，这个稍后解释)。<code>Person.prototype</code> 作为一个 “代理人” 将两者联系到了一起。</p><p>是的，<code>[[Prototype]]</code> “建造” 了这一切(注意：不是 <code>prototype</code>)。<em>几乎</em> 所有的对象在创建时都会携带一个 <code>[[Prototype]]</code> 的内部属性。这个属性的值实际上是另一个对象的引用，这是一种 <strong>关联关系</strong>，而非 “拷贝” 关系。</p><p>对上图三个内部 <code>[[Prototype]]</code> 的解释：</p><ul><li><p>构造函数(当然，函数也是对象)的 <code>[[Prototype]]</code> 是 <code>Function.prototype</code> 的引用，因为 JavaScript 中所有的函数都是由 <code>Function()</code> “构造” 的。</p></li><li><p>对象 <code>Person.prototype</code> 的 <code>[[Prototype]]</code> 是 <code>Object.prototype</code> 的引用。<code>Object.prototype</code> 是所有对象(当然，函数也是对象) 的 “终点”。</p></li><li><p>对象 <code>me</code> 的 <code>[[Prototype]]</code> 是 <code>Person.prototype</code> 的引用，而这是通过关键词 <code>new</code> 实现的。</p></li></ul><p>最后，让我们思考一个问题：<code>Function.prototype</code> 的内部 <code>[[Prototype]]</code> 指向何处？</p><p>en~~~，应该很简单。<code>Object.prototype</code> 是所有对象的 “终点”。</p><h4 id="继承同样是通过-“关联”-建立关系的"><a href="#继承同样是通过-“关联”-建立关系的" aria-hidden="true" class="header-anchor">#</a> 继承同样是通过 “关联” 建立关系的</h4><p>我们来看一个继承的例子：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Empolyee</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> title<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Person<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title
<span class="token punctuation">}</span>

Empolyee<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// A</span>
Empolyee<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Employee

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Empolyee</span><span class="token punctuation">(</span><span class="token string">'xiaoke'</span><span class="token punctuation">,</span> <span class="token string">'JavaScript Developer'</span><span class="token punctuation">)</span>
</code></pre></div><p>上面代码的 “A 行” 的表现不尽人意。如果 “构造” 函数 <code>Person()</code> 有副作用，就会影响到 <code>Employee</code> 的 “实例”。我们可以使用 <code>Object.create()</code> 代替。</p><div class="language-js extra-class"><pre class="language-js"><code>Empolyee<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// A</span>
</code></pre></div><p>最好的做法是 使用 <code>setPrototypeOf</code> 直接修改 <code>Bar.prototype</code>。</p><div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>Empolyee<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> Person<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
</code></pre></div><p>但无论上述哪种方式，意思都表示：<strong>创建新的(替换旧的) Empolyee.prototype，并把它关联到 Person.prototype</strong>。</p><h3 id="new、constructor、实例等概念隐藏了-prototype-的真实"><a href="#new、constructor、实例等概念隐藏了-prototype-的真实" aria-hidden="true" class="header-anchor">#</a> new、constructor、实例等概念隐藏了 [[Prototype]] 的真实</h3><p>在知道 JavaScript 真正的 OOP 方式是通过 “对象关联” 而非 Class 中描述的所有特性的 “拷贝”。我们不禁要思考：是什么导致 JavaScript 的 OOP 朝着 “模拟” Class 进行发展的。</p><p>结论是：函数的 <code>prototype</code>。所有的函数都默认拥有一个名为 <code>prototype</code> 的属性，指向 <code>函数.prototype</code>，同时在 “prototype chain” 中占据一个位置。</p><p>有哪些概念模糊了 JavaScript 的 OOP 的真实呢？</p><ol><li>“构造” 函数的首字母大写命名</li></ol><p>很多规范都鼓励我们采用 <em>大驼峰</em>(Upper Camel Case) 的方式命名 “构造” 函数，从而营造出 “类” 的感觉。“构造” 函数和其他函数并没有什么不同，“构造” 函数也没有构造 “实例”。</p><ol start="2"><li><code>new</code> 和 “构造” 函数</li></ol><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>上面的代码中，看到了关键字 <code>new</code>，另外我们看上去是代码执行了 “类的构造函数”。在传统的面向 Class 语言中，两者紧密结合。</p><p>似乎，我们通过这两者 “构建了 Class 的实例”。这种曲解的理解是不对的，<code>new</code> 只是 <strong>间接</strong> 地建立了两个对象的 <strong>关系</strong>。就是说，<code>new</code> 割断了对象原本的 <em>关联关系</em>(一般情况下，是 <code>Object.prototype</code>)，建立了于另一个对象 <code>构造函数.prototype</code> 的 <em>关联关系</em>。</p><p>只有 <code>new</code> 调用的函数，我们才亲切地成为 “构造函数”。我们摘录 <code>new</code> 四个步骤：</p><ul><li>一个全新的对象被构建</li><li>这个新构建的对象会被接入原型链</li><li>新构建的对象被设置为函数调用的 this 绑定</li><li>除非函数返回一个它自己的其他对象，否则这个被 new 调用的函数将自动返回这个新构建的对象</li></ul><p>还要一种直接建立两个对象之间的 <em>关联关系</em> 的方式是：<code>Object.create()</code>。</p><ol start="3"><li>“虚假” 的 constructor</li></ol><p>回顾上面的 <code>[[Prototype]]</code>、<code>prototype</code> 和 <code>constructor</code> 指向问题。几乎每个对象(当然，函数也是对象) 都有一个 <code>.constructor</code> 属性。令人费解的是，<code>me.constructor</code> 和 <code>Fun.prototype.constructor</code> 同时指向了 “构造” 函数 <code>Person</code>。</p><div class="language-js extra-class"><pre class="language-js"><code>me<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person
Fun<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person
</code></pre></div><p>这看上去像是一种误导，<code>me.constructor</code> 只是通过默认的 <code>[[Prototype]]</code> “委托” 指向了 <code>Person</code>，和 “构造” 并无关系(即，“虚假” 的关系)。</p><p>试着，举个例子。ES6 之前，我们的写法是这样的：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
Person<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'xiaoke'</span><span class="token punctuation">)</span>
</code></pre></div><p>那么，既然是 <code>Person.prototype</code> 是对象，是不是可以采用对象字面量的写法呢。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
Person<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  toString<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'xiaoke'</span><span class="token punctuation">)</span>
</code></pre></div><p>第一眼看上去似乎完全一致，但实际上存在一定的副作用。</p><div class="language-js extra-class"><pre class="language-js"><code>me<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Person <span class="token comment">// false</span>
me<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object <span class="token comment">// true</span>
</code></pre></div><p>如果认为 <code>constructor</code> 是 <code>由...构造</code> 的话。<code>a.constructor</code> 应该是 <code>Person</code> 的引用，而非 <code>Object</code>。这是怎么回事？</p><p>这是因为 <code>a</code> 并没有 <code>constructor</code> 属性，所以它委托原型链上的 <code>Person.prototype</code>；但是，由于是字面量的写法，所以 <code>Person.prototype</code> 也没有 <code>constructor</code> 属性；继续向上委托，交给顶端的 <code>Object.prototype</code>；这个对象有 <code>constructor</code> 属性，而且是内置的 <code>Object</code>。</p><p>所以，为了得到正确的结果。我们需要手动 “委托” 一下。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
Person<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  constructor<span class="token punctuation">:</span> Person<span class="token punctuation">,</span>
  toString<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'xiaoke'</span><span class="token punctuation">)</span>
</code></pre></div><p>这种方式似乎也有点问题。因为 <code>.constructor</code> 属性是不可枚举的，所以我们需要多做一些工作。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
Person<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
  toString<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>Foo<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'constructor'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  enumerable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  value<span class="token punctuation">:</span> Person
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'xiaoke'</span><span class="token punctuation">)</span>
</code></pre></div><ol start="4"><li>ES6 Class 的彻底偏航</li></ol><p>ES6 中通过 <code>class</code> 关键字将这一行为推向了深渊。我们会毫不犹豫地将 ES6 Class 的行为和传统的 Class 行为联系到一起，从而再也不容易窥探到 JavaScript OOP 的本质。</p><p>从另一方面来考虑，ES6 Class 并非一无是处。</p><p>即，<strong>ES6 Class 越来越 “近似类”了</strong>。</p><blockquote><p>既然已经走偏，不如彻底偏航。</p></blockquote><p>是的，我们无法回到 1995 年(JavaScript 诞生的年份)，正如 JavaScript 无法回头。既然如此，何不抬头向前看。随着 ES6 Class 新特性的补充和完善，或许有那么一天，我们不必去深究隐藏在 ES6 Class 下的那一头巨大的 “猛兽”。</p><h3 id="me-和-person-prototype-是一种-“委托”-的关联关系"><a href="#me-和-person-prototype-是一种-“委托”-的关联关系" aria-hidden="true" class="header-anchor">#</a> me 和 Person.prototype 是一种 “委托” 的关联关系</h3><p>“委托” 是一种模拟 “原型链” 工作原理的说法。</p><div class="language-js extra-class"><pre class="language-js"><code>me<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>当 <code>toString()</code> 不直接存在于 <code>me</code> 中，就会将 <code>toSting()</code> “委托” 给 <code>me</code> 关联的 <code>Person.prototype</code>；如果还没有，就还会沿着 “原型链” 继续向上查找；如果找不到，则抛出一个 <code>TypeError</code> 类型的错误。</p><p>但是，试图覆盖某个属性或方法时，情况要稍微复杂一点：</p><div class="language-js extra-class"><pre class="language-js"><code>me<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'JavaScript Developer'</span>
</code></pre></div><ol><li><p>如果在 “原型链” 上存在 <code>title</code> 的一个可读的(<code>writable: true</code>)属性，就会直接在 <code>me</code> 中添加(或替换)一个 <code>title</code> 属性，“屏蔽” 之前的属性；</p></li><li><p>如果在 “原型链” 上存在 <code>title</code> 的一个只读的(<code>writable: false</code>)属性，无法修改已有属性或在 <code>me</code> 上添加(或替换) <code>title</code> 属性；</p></li><li><p>如果在 “原型链” 上存在 <code>title</code> 属性，并且它是一个 <code>setter</code>，则只会调用这个 <code>setter</code>。</p></li></ol><h3 id="继承-2"><a href="#继承-2" aria-hidden="true" class="header-anchor">#</a> 继承</h3><h2 id="es6-class"><a href="#es6-class" aria-hidden="true" class="header-anchor">#</a> ES6 Class</h2><p>接下来的部分将抛开 “真实的 Class 理论”，而挖掘 ES6 中 Class 的实现 - 一种 “近似” 的 Class 实现。</p><p>ES6 Class 内部只有方法，例子如下：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">create</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">this</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">toString</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
  <span class="token punctuation">}</span>
  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
  <span class="token punctuation">}</span>
  <span class="token keyword">set</span> <span class="token function">name</span><span class="token punctuation">(</span>anotherName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> anotherName
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从方法的功能上，可以将 ES6 Class 的所有方法划分为三类：<code>constructor</code>、<code>static</code> 和 <code>prototype</code>。</p><p>同时，<code>static</code> 和 <code>prototype</code> 类别中又支持 Gettet、Setter、Computed 方法、Gengerator 等写法。</p><h3 id="constructor"><a href="#constructor" aria-hidden="true" class="header-anchor">#</a> constructor</h3><p>当然，ES6 Class 的实例化也是通过 <code>constructor()</code> 来实现的。该方法是内部方法 <code>[[Construct]]</code> 的一个实现。每个 Class 都有一个 <code>constructor()</code> 方法。不显式指定，则默认为：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="覆盖-constructor-的结果"><a href="#覆盖-constructor-的结果" aria-hidden="true" class="header-anchor">#</a> 覆盖 constructor 的结果</h4><p>值得一提的是，和 ES6 之前的方式一样，我们可以显式覆盖 <code>constructor</code> 的结果。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="static"><a href="#static" aria-hidden="true" class="header-anchor">#</a> static</h3><p>ES6 Class 可以为所有的方法和 Getter/Setter 使用 static 属性。static 方法属于 Class 本身，其实例不可用。</p><p>那么，问题是：Class 中的 static 方法有什么存在的价值呢<sup>3</sup>？</p><ol><li>很多实用的工具类函数，可以被定义成 static</li></ol><p>比如，一个名为 <code>MyMath</code> 的 Class，倘若 <code>MyMath</code> 对象对外提供一个 <code>random()</code> 的工具方法，定义为 static 方法会比普通的成员方法使用上更为简单，也不会担心会被子类重写。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyMath</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>返回 Class 的实例</li></ol><p>不管是为了向下兼容还是其他，我们可以通过定义 static 方法来返回我们的 Class 实例。比如：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">create</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">this</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token keyword">get</span> <span class="token function">defaultPerson</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">this</span><span class="token punctuation">(</span><span class="token string">'xiaoke'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>再例如 <code>Promise.resolve()</code> 返回了一个 Promise。</p><h4 id="不推荐的-static-方法定义方式"><a href="#不推荐的-static-方法定义方式" aria-hidden="true" class="header-anchor">#</a> 不推荐的 static 方法定义方式</h4><p>还记得吗，Class 就是一个 <code>function</code>。我们还可以通过下面的方式来添加一个 static 方法：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Person<span class="token punctuation">.</span><span class="token function-variable function">create</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code></pre></div><p>但是这种做法并不推荐。</p><h3 id="prototype"><a href="#prototype" aria-hidden="true" class="header-anchor">#</a> prototype</h3><p>以下面这个例子而言：<code>toString()</code> 就是 <code>Person.prototype</code> 上的方法。这些方法一般可以被实例继承。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token punctuation">}</span>
  <span class="token function">toString</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="es6-class-继承"><a href="#es6-class-继承" aria-hidden="true" class="header-anchor">#</a> ES6 Class 继承</h2><p>在 ES6 Class 继承中，我们会多认识 <code>super</code> 和 <code>extends</code> 两个关键字。例子如下：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">create</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">this</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">toString</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> title<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title
  <span class="token punctuation">}</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> - </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">'xiaoke'</span><span class="token punctuation">,</span> <span class="token string">'JavaScript Developer'</span><span class="token punctuation">)</span>
</code></pre></div><p><code>[[Prototype]]</code> 关系图如下图所示：</p><p><img src="https://github.com/maoxiaoke/xiaokedada/blob/master/assets/subclass-prototype.png?raw=true" alt></p><h3 id="子类的-prototype-指向-“父类”"><a href="#子类的-prototype-指向-“父类”" aria-hidden="true" class="header-anchor">#</a> 子类的 [[Prototype]] 指向 “父类”</h3><p>这一点和 ES6 之前的有点不同。同时这一点也导致 “父类” 的 static 成员函数会被接入原型链。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> me <span class="token operator">=</span> Employee<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">'xiaoke'</span><span class="token punctuation">,</span> <span class="token string">'JavaScript Developer'</span><span class="token punctuation">)</span>
me<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &quot;xiaoke - JavaScript Developer&quot;</span>
</code></pre></div><h3 id="super"><a href="#super" aria-hidden="true" class="header-anchor">#</a> super</h3><p>从上面的例子中，我们可以看到 <code>super</code> 的两种使用方式。</p><ol><li>用在 <code>constructor</code> 中，<code>super</code> 指代 “父类” 的 “构造函数”</li></ol><p>这种情况下，<code>super()</code> 就等同于调用 <code>new Person()</code>。千万不要误以为的是 <code>super</code> 和 <code>Person</code> 是等价的。也就是说，在 “子类” 的 “构造函数” 中，<code>super.prototype</code> 是无效的。</p><p>还需要讲解的一点是：在 “子类” 的 “构造函数” 中，在未调用 <code>super()</code> 之前，无法访问 <code>this</code>。这么做是有一定道理的。比如：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">PolitePerson</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> title<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">greeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 这是不被允许的</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">greeting</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello You!'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> me <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">'xiaoke'</span><span class="token punctuation">,</span> <span class="token string">'JavaScript Developer'</span><span class="token punctuation">)</span>
</code></pre></div><p>假设某一天，我们需要对 <code>greeting()</code> 进行修改。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">greeting</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span> <span class="token comment">// 可是这个时候，this.name 还未定义</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为了避免这样的陷阱，<strong>强制在 “构造函数” 中使用 <code>this</code>, 就需要先调用 <code>super()</code></strong>。</p><ol start="2"><li>用在成员 <code>prototype</code> 方法中，<code>super</code> 指代 “父类.prototype”</li></ol><p>这种情况，可以使用代码类比 <code>super</code> 的效果。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> homeObject <span class="token operator">=</span> Employee<span class="token punctuation">.</span>prototype
<span class="token keyword">const</span> superObject <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>homeObject<span class="token punctuation">)</span>
<span class="token keyword">const</span> superMethod <span class="token operator">=</span> superObject<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> result <span class="token operator">=</span> superMethod<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
</code></pre></div><p>也就是说，当调用 <code>super.toString()</code> 时，使用的是当前的 <code>this</code> (指向 <code>me</code>)。</p><p>上诉代码似乎也表明一个事实：<code>super</code> 并非和 <code>this</code> 一样 “动态绑定”。在内部有一个 <code>[[HomeObject]]</code> 记录着使用了 <code>super</code> 的函数的环境，在声明时 <code>[HomeObject]]</code> 就已经确定了，<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-function-environment-records" target="_blank" rel="noopener noreferrer">也无法再次被修改<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><h3 id="extends"><a href="#extends" aria-hidden="true" class="header-anchor">#</a> extends</h3><p><code>extends</code> 语句恐怕是 ES6 Class 中最为闪光的一点了。</p><p><code>Employee extends Person</code> 即是说：将 <code>Employee.prototype</code> 和 <code>Person.prototype</code> “关联” 起来。</p><p>不止是如此，<code>extends</code> 让我们(终于)有能力扩展内建对象的能力了。</p><h4 id="“父类化”-es5-的内建对象"><a href="#“父类化”-es5-的内建对象" aria-hidden="true" class="header-anchor">#</a> “父类化” ES5 的内建对象</h4><p>ES6 之前，很多内置的对象比如 <code>Array</code>、<code>Function</code> 等等都无法 <a href="http://speakingjs.com/es5/ch28.html" target="_blank" rel="noopener noreferrer">“父类化”<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。比如：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myArray</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Array<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
myArray<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
</code></pre></div><h4 id="es6-的可能性"><a href="#es6-的可能性" aria-hidden="true" class="header-anchor">#</a> ES6 的可能性</h4><p>ES5 Class 弥补了这方面的缺陷。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">myArray</span> <span class="token keyword">extends</span> <span class="token class-name">Array</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">first</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
  <span class="token function">last</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">]</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="es-next"><a href="#es-next" aria-hidden="true" class="header-anchor">#</a> ES Next</h2><h3 id="proposal-class-fields"><a href="#proposal-class-fields" aria-hidden="true" class="header-anchor">#</a> proposal-class-fields</h3><h2 id="其他概念"><a href="#其他概念" aria-hidden="true" class="header-anchor">#</a> 其他概念</h2><h3 id="new-target"><a href="#new-target" aria-hidden="true" class="header-anchor">#</a> new.target</h3><h3 id="symbol-species"><a href="#symbol-species" aria-hidden="true" class="header-anchor">#</a> Symbol.species</h3><h2 id="class-单例模式"><a href="#class-单例模式" aria-hidden="true" class="header-anchor">#</a> Class 单例模式</h2><p>单例(singleton)是设计模式<sup>4</sup>中常见的一种，是说 <strong>确保只存在唯一一个 Class 实例</strong>。这是一种较易实现的模式，但下面的方式是有缺陷的<sup>5</sup>。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">class</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token punctuation">}</span>
  <span class="token keyword">get</span> <span class="token function">personName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token string">'xiaoke'</span><span class="token punctuation">)</span>
</code></pre></div><p>因为无法 <strong>确保</strong> 只存在唯一一个 Class 实例。这是因为我们可以很容易地使用 <code>constructor()</code> 来创建 Class 的另一个实例。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> anotherInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">singleton<span class="token punctuation">.</span>constructor</span><span class="token punctuation">(</span><span class="token string">'yuer'</span><span class="token punctuation">)</span> <span class="token comment">// oh, no~~~</span>
</code></pre></div><p>不过这也提醒我们应该在 <code>constuctor()</code> 做点什么来防止这种行为。我们可以定义一个变量来存储这个实例，当再次调用构造函数是，如果实例存在，则返回这个实例；否则，创建一个实例<sup>6</sup>。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> instance
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;name&quot;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// ES Next</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> instance
  <span class="token function">constructor</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> instance
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="我们真的需要吗"><a href="#我们真的需要吗" aria-hidden="true" class="header-anchor">#</a> 我们真的需要吗</h3><p>疑问发人深省！！！一个简单的字面量 Object 是不是就可以满足要求？JavaScript 是不是原生就支持单例模式？那为何我们还需要多此一举？</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'xiaoke'</span><span class="token punctuation">,</span>
  <span class="token keyword">get</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="class-的批评"><a href="#class-的批评" aria-hidden="true" class="header-anchor">#</a> Class 的批评</h2><p>虽然有近似 Class 的语法，但是 JavaScript 的这个近似 Class 的表象之下，其实和真实的 Class 完全不一样。</p><ol><li>syntax 和 semantics 的分离</li></ol><h2 id="reference"><a href="#reference" aria-hidden="true" class="header-anchor">#</a> Reference</h2><p>[1] https://searchmicroservices.techtarget.com/definition/object-oriented-programming-OOP</p><p>[2] https://stackoverflow.com/questions/2078978/functional-programming-vs-object-oriented-programming</p><p>[3] https://www.reddit.com/r/javascript/comments/58yvgk/what_is_the_point_of_static_methods_in_classes/</p><p>[4] Design Patterns - Elements of Reusable Object-Oriented Softwave</p><p>[5] https://stackoverflow.com/questions/38739499/anonymous-class-instance-is-it-a-bad-idea</p><p>[6] http://adambien.blog/roller/abien/entry/singleton_pattern_in_es6_and</p></div><div class="page-edit"><div class="edit-link"><a href="https://github.com/maoxiaoke/xiaokedada/edit/master/JavaScript/ES6-Class.md" target="_blank" rel="noopener noreferrer">在 Github 上编辑此页</a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div><!----></div><div class="page-nav"><p class="inner"><span class="prev">
        ← <a href="/JavaScript/ES6-Let-and-Const.html" class="prev">
          最佳实践，使用 let/const
        </a></span><span class="next"><a href="/JavaScript/ES6-Symbols.html">
          万物皆不同 - Symbols
        </a> →
      </span></p></div></div></div></div>
    <script src="/assets/js/28.8aaaacba.js" defer></script><script src="/assets/js/app.843b634b.js" defer></script>
  </body>
</html>
