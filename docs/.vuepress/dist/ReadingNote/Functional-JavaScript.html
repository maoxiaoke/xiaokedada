<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Functional JavaScript | XIAOKEDADA</title>
    <meta name="description" content="Write something useful and funny">
    <link rel="icon" href="/favicon.png">
    
    <link rel="preload" href="/assets/css/41.styles.e762a268.css" as="style"><link rel="preload" href="/assets/js/app.410137e2.js" as="script"><link rel="preload" href="/assets/js/1.92a2d4aa.js" as="script"><link rel="prefetch" href="/assets/js/21.d6b1d746.js"><link rel="prefetch" href="/assets/js/2.39045e1a.js"><link rel="prefetch" href="/assets/js/3.2b022ecb.js"><link rel="prefetch" href="/assets/js/4.8e445ab4.js"><link rel="prefetch" href="/assets/js/5.84612907.js"><link rel="prefetch" href="/assets/js/6.15a5821d.js"><link rel="prefetch" href="/assets/js/7.06331f67.js"><link rel="prefetch" href="/assets/js/8.6c2278fd.js"><link rel="prefetch" href="/assets/js/9.ae547c14.js"><link rel="prefetch" href="/assets/js/10.7d5c0e89.js"><link rel="prefetch" href="/assets/js/11.f8684595.js"><link rel="prefetch" href="/assets/js/12.bff7ff72.js"><link rel="prefetch" href="/assets/js/13.c4b65b5e.js"><link rel="prefetch" href="/assets/js/14.245ecee9.js"><link rel="prefetch" href="/assets/js/15.8a7deb3e.js"><link rel="prefetch" href="/assets/js/16.0ca0755e.js"><link rel="prefetch" href="/assets/js/17.8909b53c.js"><link rel="prefetch" href="/assets/js/18.817df937.js"><link rel="prefetch" href="/assets/js/19.ee383a71.js"><link rel="prefetch" href="/assets/js/20.0a4da2de.js"><link rel="prefetch" href="/assets/js/0.2613590b.js"><link rel="prefetch" href="/assets/js/22.ebf4e4dd.js"><link rel="prefetch" href="/assets/js/23.b3a5d78d.js"><link rel="prefetch" href="/assets/js/24.24f6d16a.js"><link rel="prefetch" href="/assets/js/25.9b4594b3.js"><link rel="prefetch" href="/assets/js/26.f9cb806b.js"><link rel="prefetch" href="/assets/js/27.e45cf68a.js"><link rel="prefetch" href="/assets/js/28.5f710b0b.js"><link rel="prefetch" href="/assets/js/29.f2ebea39.js"><link rel="prefetch" href="/assets/js/30.e5541a7f.js"><link rel="prefetch" href="/assets/js/31.b78997b0.js"><link rel="prefetch" href="/assets/js/32.c7364e30.js"><link rel="prefetch" href="/assets/js/33.ae985e87.js"><link rel="prefetch" href="/assets/js/34.abe148b9.js"><link rel="prefetch" href="/assets/js/35.18140cbf.js"><link rel="prefetch" href="/assets/js/36.9493905a.js"><link rel="prefetch" href="/assets/js/37.7d93e401.js"><link rel="prefetch" href="/assets/js/38.0eb7992d.js"><link rel="prefetch" href="/assets/js/39.0cb28492.js"><link rel="prefetch" href="/assets/js/40.fde62018.js">
    <link rel="stylesheet" href="/assets/css/41.styles.e762a268.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      XIAOKEDADA
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/JavaScript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/FirstMeet/" class="nav-link">FirstMeet系列</a></div><div class="nav-item"><a href="/CSS/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/ReadingNote/" class="nav-link router-link-active">读书笔记</a></div><div class="nav-item"><a href="/GatherAll/" class="nav-link">R &amp; T</a></div><a href="https://github.com/maoxiaoke/xiaokedada" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/JavaScript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/FirstMeet/" class="nav-link">FirstMeet系列</a></div><div class="nav-item"><a href="/CSS/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/ReadingNote/" class="nav-link router-link-active">读书笔记</a></div><div class="nav-item"><a href="/GatherAll/" class="nav-link">R &amp; T</a></div><a href="https://github.com/maoxiaoke/xiaokedada" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>读书笔记</span><!----></p><ul class="sidebar-group-items"><li><a href="/ReadingNote/Functional-JavaScript.html" class="active sidebar-link">Functional JavaScript</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ReadingNote/Functional-JavaScript.html#what-is-functional-programming" class="sidebar-link">What is Functional Programming</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/Functional-JavaScript.html#why-functional-programming" class="sidebar-link">Why Functional Programming</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/Functional-JavaScript.html#函数是一等公民" class="sidebar-link">函数是一等公民</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/Functional-JavaScript.html#将函数和函数组合起来" class="sidebar-link">将函数和函数组合起来</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/Functional-JavaScript.html#函数式编程的难兄难弟-recursion" class="sidebar-link">函数式编程的难兄难弟 -- Recursion</a></li><li class="sidebar-sub-header"><a href="/ReadingNote/Functional-JavaScript.html#purity-immutability-and-policies-for-change" class="sidebar-link">Purity, Immutability, and Policies for Change</a></li></ul></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="functional-javascript"><a href="#functional-javascript" aria-hidden="true" class="header-anchor">#</a> Functional JavaScript</h1><blockquote><p>by Michael Fogus</p></blockquote><h2 id="what-is-functional-programming"><a href="#what-is-functional-programming" aria-hidden="true" class="header-anchor">#</a> What is Functional Programming</h2><p>Functional programming is the use of functions that transform values into units of abstraction, subsequently used to build software systems.</p><blockquote><p>函数式编程是将<strong>值转换为抽象单元</strong>的一种函数使用方式，随后用来构建软件系统</p></blockquote><h3 id="以函数为抽象单元"><a href="#以函数为抽象单元" aria-hidden="true" class="header-anchor">#</a> 以函数为抽象单元</h3><p>实现抽象的一种方式是：函数隐藏了实现细节。这种抽象函数的好处在于：</p><p>Make it run, the make it right, then make it fast</p><blockquote><p>by Kent Beck</p></blockquote><p>举个栗子，函数 parseInteger() 期待一个字符串作为解析输入。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">parseInteger</span> <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_<span class="token punctuation">.</span><span class="token function">isString</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Expecting a string&quot;</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;Could not parse string:&quot;</span><span class="token punctuation">,</span> str<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    a <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> a
<span class="token punctuation">}</span>
</code></pre></div><p>上述这个栗子，能比较完整地表达我们的意图：对传入的字符串进行解析。但是我们进一步思考，如果我们想修改输出的信息，就需要修改对应的代码行。</p><p>一个较好的方式是：将错误、信息和警告<strong>抽象</strong>成不同的函数：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fail</span> <span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span> <span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">warn</span> <span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;WARNING:&quot;</span><span class="token punctuation">,</span> msg<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过上述抽象函数，我们将栗子改写成：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">parseInteger</span> <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_<span class="token punctuation">.</span><span class="token function">isString</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&quot;Expecting a string&quot;</span><span class="token punctuation">)</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">warn</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;Could note parse string:&quot;</span><span class="token punctuation">,</span> str<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    a <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> a
<span class="token punctuation">}</span>
</code></pre></div><p>我们将错误和警告进行抽象化了，在调用时只需传入对应的参数，而不用考虑函数的具体实施，这就是一种数据抽象。这种抽象的好处在于，当修改进行时，我们只需要修改对应的抽象函数。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">warn</span> <span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&quot;WARNING:&quot;</span><span class="token punctuation">,</span> msg<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>行为包含在单一的函数中，因此一个函数可以被多个新函数提供相似或不同行为的函数所取代</strong>。</p><h3 id="以函数为行为单元"><a href="#以函数为行为单元" aria-hidden="true" class="header-anchor">#</a> 以函数为行为单元</h3><p>隐藏数据和行为是函数成为抽象单元的一种方式，另一种是<strong>提供简单的方式来存储和传递基本行为的离散单元</strong>。</p><p>下面的栗子可能不那么好。通常情况下，我们使用<code>[]</code>进行数组的索引。现在我们对这种索引方式进行<em>抽象</em>。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">nth</span> <span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为了使得函数更为可靠，提供一个判断 <code>arr</code> 是否是数组或字符串的函数抽象。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isIndexed</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> _<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token operator">||</span> _<span class="token punctuation">.</span><span class="token function">isString</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>则 <code>nth()</code> 的实现如下：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">nth</span> <span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_<span class="token punctuation">.</span><span class="token function">isNumber</span> <span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&quot;Expected a number as a index&quot;</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isIndexed</span> <span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">'Not supported on non-indexed type'</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">fail</span><span class="token punctuation">(</span><span class="token string">&quot;Index value is out of bounds&quot;</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> a<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><hr><h2 id="why-functional-programming"><a href="#why-functional-programming" aria-hidden="true" class="header-anchor">#</a> Why Functional Programming</h2><p>The major evolution that is still going on for me is towards a more functional programming style, which involves unlearning a lot of old habits, and backing away from some OOP directions.</p><blockquote><p>对我来说，主要的演变仍是朝着一种更为函数式的风格发展，这意味着移除很多旧的习惯，并且远离一些 OOP 的方向 -- John Carmack</p></blockquote><h3 id="difference-between-functional-programming-and-oop"><a href="#difference-between-functional-programming-and-oop" aria-hidden="true" class="header-anchor">#</a> Difference between Functional Programming and OOP</h3><blockquote><p>我的理解：OOP 编程范式使用封装、继承和多态三要素(使用这三者来解释 OOP 对于理解 OOP 完全没有任何帮助)。单就封装而言，指的是将一个对象<em>使用 class 进行包装一些属于它一类的属性和方法</em>(就是说，对 OOP 而言，世间万物可以抽象成一些自我属性和所能执行的操作的个体，就是实例)。</p></blockquote><p>未完待续</p><h3 id="javascrpt-s-multiple-paradigms"><a href="#javascrpt-s-multiple-paradigms" aria-hidden="true" class="header-anchor">#</a> JavaScrpt's Multiple Paradigms</h3><p>JavaScript 并不是严格的 functional programming 语言，所以也支持多类编程范式。</p><h4 id="imperative-programming-命令式编程"><a href="#imperative-programming-命令式编程" aria-hidden="true" class="header-anchor">#</a> Imperative programming -- 命令式编程</h4><p>命令式编程是通过细致的完全的代码来实现算法的细节。</p><blockquote><p>OOP 也属于 imperative programming ？</p></blockquote><p>下面是一个数瓶子的算法，采用命令式编程。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> lyrics <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> bottles <span class="token operator">=</span> <span class="token number">99</span><span class="token punctuation">;</span> bottles <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>bottles<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>bottles <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   lyrics<span class="token punctuation">.</span><span class="token function">push</span> <span class="token punctuation">(</span>bottles <span class="token operator">+</span> <span class="token string">'bottles of beer'</span><span class="token punctuation">)</span>
   lyrics<span class="token punctuation">.</span><span class="token function">push</span> <span class="token punctuation">(</span><span class="token string">'Take One down and pass it'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
 <span class="token keyword">else</span> <span class="token punctuation">{</span>
   lyrics<span class="token punctuation">.</span><span class="token function">push</span> <span class="token punctuation">(</span><span class="token string">'No more beer!'</span><span class="token punctuation">)</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面就是命令式编程的一个例子，缺点很明显：<strong>一次性操作，很难重用</strong>。</p><hr><h2 id="函数是一等公民"><a href="#函数是一等公民" aria-hidden="true" class="header-anchor">#</a> 函数是一等公民</h2><p>一等的意思就是 “something is just a value”。即在 JavaScript 中，函数类似于值。可以保存在变量中，作为数组的一个元素，作为对象的方法，可随时被创建，能够被当做参数传递，或者返回。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">firstClass</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">'yuer'</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> firstClassArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'xiaoke'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">'yuer'</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> firstClassObj <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'xiaoke'</span><span class="token punctuation">,</span> fun<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">'yuer'</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token number">42</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 利用 IIFE </span>
<span class="token keyword">function</span> <span class="token function">weridAdd</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> n <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">42</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="applicative-programming"><a href="#applicative-programming" aria-hidden="true" class="header-anchor">#</a> Applicative Programming</h3><p>Applicative Programming 的定义：<strong>函数 A 作为参数提供给函数 B 调用</strong>。这是函数式编程处理函数的一个非常窄的方面，<code>map</code>、<code>reduce</code> 和 <code>filter</code> 便是三个非常典型的例子。</p><h4 id="集合中心化编程-collection-centric-programming"><a href="#集合中心化编程-collection-centric-programming" aria-hidden="true" class="header-anchor">#</a> 集合中心化编程 Collection-Centric Programming</h4><p>三个典型例子的典型特点是，<strong>接收一个数组集合</strong>。但这对<strong>键/值对集合</strong>仍然适用。函数式编程对这类操作集合中元素的任务非常有用。</p><h3 id="高阶函数-high-order-functions"><a href="#高阶函数-high-order-functions" aria-hidden="true" class="header-anchor">#</a> 高阶函数 -- High Order Functions</h3><p>满足以下条件之一的函数，即为“高阶函数”的定义：</p><ul><li>以一个函数作为参数</li><li>返回一个函数作为结果</li></ul><p>在涉及到高阶函数的时候，需要提到一个老生常谈的概念 -- 闭包。闭包和一等公民函数是齐头并进的，<strong>虽然不支持一等公民函数身份的语言也支持闭包</strong>(这里请举出具体例子！)。但因为有了一等公民函数，所以闭包在 JavaScript 简直无处不在。</p><blockquote><p>此书的作者是这样定义闭包的：In a sentence, a closure is a function that captures the external bindings (i.e., not its own arguments) contained in the scope in which it was defined for later use (even after that scope has completed). -- 不强调说法的正确性，闭包是一个函数的说法也值得讨论。</p></blockquote><p>在下面这个例子中，返回一个函数作为结果</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">makeAdder</span> <span class="token punctuation">(</span><span class="token constant">CAPTURED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>free<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> free <span class="token operator">+</span> <span class="token constant">CAPTURED</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> add10 <span class="token operator">=</span> <span class="token function">makeAdder</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> <span class="token function">add10</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment">// 15</span>
</code></pre></div><p>一个函数包含内部函数，则内部函数都可以访问外部函数定义的变量，并进行捕获，甚至通过 <code>return</code> 来逃脱外部函数，这些变量，称之为“free variables”；访问、捕获或帮助自由变量逃脱的函数，就称之为“捕获函数”(例子中，即匿名函数)； 存在于函数内部，但不是局部声明的变量，称之为“capture variables”(比如传入的 CAPTURED )。</p><p>一个问题是，捕获变量通常是<strong>暴露</strong>在外的，从而较大的风险。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">showObj</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 这种为了返回闭包而另外包裹一层，是否值得考虑？</span>
    <span class="token keyword">return</span> obj   
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'yuer'</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> showo <span class="token operator">=</span> <span class="token function">showObj</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span>
<span class="token function">showo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// { name: 'yuer' }</span>
o<span class="token punctuation">.</span>newProperty <span class="token operator">=</span> <span class="token string">'age'</span>
<span class="token function">showo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// { name: 'yuer', newProperty: 'age' }</span>
</code></pre></div><p>为了尽可能地减少暴露捕获变量的风险，通常使用以下的方式，将捕获的变量作为私有变量。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> privateCap <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token constant">PRIVATE</span> <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    inc<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token constant">PRIVATE</span> <span class="token operator">+</span> n
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    dec<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token constant">PRIVATE</span> <span class="token operator">-</span> n
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="接收函数作为参数的高阶函数"><a href="#接收函数作为参数的高阶函数" aria-hidden="true" class="header-anchor">#</a> 接收函数作为参数的高阶函数</h4><p>典型的 <code>map</code>、<code>reduce</code> 和 <code>filter</code> 都可以接收一个函数作为参数。让我们再深入思考一下。</p><p><em>使用函数，而不是值</em> - 函数是 Functional Programming 的精髓，所以这句话有一定意义。</p><p>比如，我们设计一个将一个值复制多次的函数：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">repeat</span> <span class="token punctuation">(</span>times<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> _<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span>times<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的这个例子中，我们遍历数组中的元素，并传递被复制的值。这个例子中，是以 <em>值</em> 为主导的设计。<strong>一个函数将一个值重复多次是可以的，但是重复计算次数的函数则更好。</strong></p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">repeatedly</span> <span class="token punctuation">(</span>times<span class="token punctuation">,</span> fun<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> _<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span>times<span class="token punctuation">)</span><span class="token punctuation">,</span> fun<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">repeatedly</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">'a'</span><span class="token punctuation">)</span>
<span class="token function">repeatedly</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p><code>repeatedly()</code> 的长处在于：除了可以将一个值复制多次，还扩展了其他无限可能。</p><h4 id="返回其他函数的高阶函数"><a href="#返回其他函数的高阶函数" aria-hidden="true" class="header-anchor">#</a> 返回其他函数的高阶函数</h4><p>一个非常简单的例子：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">always</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> value
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这几乎成了函数式编程的一种范式(pattern) -- 返回一个固定的常量。但需要注意的是，返回其他函数的高阶函数通常和闭包揉和在一起，闭包返回的函数是独一的，内部闭包的捕获也是唯一的。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token function">always</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token keyword">let</span> g <span class="token operator">=</span> <span class="token function">always</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//false</span>
</code></pre></div><p>使用返回其他函数的高阶函数的一个用处在于：<strong>传入高阶函数的参数可以用来配置返回的函数</strong>。我们最开始的那个例子。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> add100 <span class="token operator">=</span> <span class="token function">makeAdder</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token function">add100</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>传入的值 <code>100</code> 可以用来<em>配置</em>返回的函数 <code>add100</code></p></blockquote><hr><h2 id="将函数和函数组合起来"><a href="#将函数和函数组合起来" aria-hidden="true" class="header-anchor">#</a> 将函数和函数组合起来</h2><p>将函数和函数组合起来的精髓在于：: using existing parts in well-known ways to build up new behaviors that can later serve as behaviors themselves.(以一种众所周知的方式使用已经存在的部分来建立新的行为，并能在之后亦能作为行为所服务)</p><blockquote><p>有点难懂？我们先来介绍将函数和函数组合起来的一种方法 - 柯里化</p></blockquote><h3 id="柯里化-currying"><a href="#柯里化-currying" aria-hidden="true" class="header-anchor">#</a> 柯里化 -- Currying</h3><p>柯里化 - <strong>为函数接收的每一个参数返回一个函数</strong></p><p>对于传统的写法，函数 <code>fun(a,b,c)</code> 会全部接受所有参数。然而，柯里化会逐个为 a, b 和 c 返回一个函数。</p><p><img src="http://p3puylt4n.bkt.clouddn.com/currying.png" alt="currying"></p><p>和之前提到的 <em>配置</em> 函数非常类似，柯里化逐个进行配置函数，直到每个参数都覆盖到。</p><h4 id="向左柯里化还是向右柯里化"><a href="#向左柯里化还是向右柯里化" aria-hidden="true" class="header-anchor">#</a> 向左柯里化还是向右柯里化</h4><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">leftCurryDiv</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n <span class="token operator">/</span> d
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">rightCurryDiv</span> <span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> n <span class="token operator">/</span> d
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>目前的建议是使用向左柯里化，即右边的参数逐个往左边进行。有一个比较重要的原因是 JavaScript 不对函数参数的数目进行限制。这对于从左往右的 partial application (部分编程) 是有关系的。</p><h4 id="自动柯里化参数"><a href="#自动柯里化参数" aria-hidden="true" class="header-anchor">#</a> 自动柯里化参数</h4><p>前面 <code>leftCurryDiv()</code> 和 <code>rightCurryDiv()</code> 的例子都需要手动进行柯里化。我们来建立这样的一个函数：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">curry</span> <span class="token punctuation">(</span>fun<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">fun</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>函数接收一个函数作为参数，并返回一个接收一个参数的函数。</p></blockquote><p>在 JavaScript 中，这样的函数非常有用。我们举一个例子：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token string">'11'</span><span class="token punctuation">,</span> <span class="token string">'11'</span><span class="token punctuation">,</span> <span class="token string">'11'</span><span class="token punctuation">,</span> <span class="token string">'11'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span>
<span class="token comment">// [ 11, NaN, 3, 4 ]</span>
</code></pre></div><p>结果是不是和我们的预期不一致？原因呢，这是因为 <code>Array.prototype.map()</code> 接收三个参数，分别是(当前值, [index], [数组本身])。恰巧的是，<code>parseInt()</code> 接收第二个可选参数作为解析的基数。</p><p>我们借助 <code>curry()</code> 函数来限定每次调用 <code>parseInt()</code> 只接受一个参数。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token string">'11'</span><span class="token punctuation">,</span> <span class="token string">'11'</span><span class="token punctuation">,</span> <span class="token string">'11'</span><span class="token punctuation">,</span> <span class="token string">'11'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">curry</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>像 <code>curry()</code> 可以显式地控制函数被调用时，修正(或忽略)用于特例化的可选参数，从而通过柯里化将参数明确下来。</p></blockquote><p>比如，我们还可以使用柯里化来确定两个参数：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">curry2</span> <span class="token punctuation">(</span>fun<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>secondArg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>firstArg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">fun</span><span class="token punctuation">(</span>firstArg<span class="token punctuation">,</span> secondArg<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>注意，这个例子我们使用的向左柯里化</p></blockquote><p>用这个例子来定义我们的除法函数。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">div</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> n <span class="token operator">/</span> b <span class="token punctuation">}</span>
<span class="token keyword">let</span> div10 <span class="token operator">=</span> <span class="token function">curry2</span><span class="token punctuation">(</span>div<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token function">div10</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>  <span class="token comment">// 5</span>
</code></pre></div><p>由此可以看到，柯里化可以指定 JavaScript 的行为，并将现有函数的行为<em>组合</em>为函数。</p><p>另外，使用柯里化比较容易产生流利的函数 API，其中一条通用的规则是：API 是否要利用函数高阶函数？如果答案是肯定的，那么至少有一个参数的柯里化是合适的。</p><h3 id="partial-application"><a href="#partial-application" aria-hidden="true" class="header-anchor">#</a> Partial Application</h3><p>柯里化是逐次返回返回消耗的参数的函数，直至参数耗尽。而 Partial Application 指的是<strong>函数已经部分执行，等待接收剩余的参数之后会立即执行</strong>。</p><p>比如下面这个例子，部分应用一个已知的参数。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">partialOne</span><span class="token punctuation">(</span>fun<span class="token punctuation">,</span> arg1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token comment">/* args */</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> args <span class="token operator">=</span> <span class="token function">construct</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span> <span class="token comment">// construct 接收一个参数和数组，并将元素放置在数组的前面</span>
    <span class="token keyword">return</span> fun<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>fun<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> over10PartOne <span class="token operator">=</span> <span class="token function">partialOne</span><span class="token punctuation">(</span>div<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
<span class="token function">over10PartOne</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre></div><p>部分应用两个已知的参数。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">partialTwo</span> <span class="token punctuation">(</span>fun<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token comment">/* args */</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> args <span class="token operator">=</span> <span class="token function">construct</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
    <span class="token keyword">return</span> fun<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>fun<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> over10PartTwo <span class="token operator">=</span> <span class="token function">partialTwo</span><span class="token punctuation">(</span>div<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token function">over10PartTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 5</span>
</code></pre></div><hr><h2 id="函数式编程的难兄难弟-recursion"><a href="#函数式编程的难兄难弟-recursion" aria-hidden="true" class="header-anchor">#</a> 函数式编程的难兄难弟 -- Recursion</h2><p>递归是一类自吸收(self-absorbed)函数(自己调用自己)。递归和 Function Programming 有着千丝万缕的关系。主要表现在：</p><ul><li>Recursive solutions involve the use of a single abstraction applied to subsets of a common problem - 使用单抽象的方式应用于一个问题的子集</li><li>Recursion can hide mutable state - 能够隐藏易变(能够被修改)的状态</li><li>Recursion is one way to implement laziness and infinitely large structures -实现惰性和无限大结构的一种方式</li></ul><blockquote><p>有些难懂是不是！！！</p></blockquote><p>我们来举个例子说明如何实现一个递归函数。定义一个函数，返回数组的长度。递归的想法是：</p><ul><li>如果数组为空，返回 0 (这是递归终止条件)</li><li>用数组剩余的元素调用该函数，结果 +1</li></ul><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">myLength</span> <span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">0</span> <span class="token punctuation">}</span>
  <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">myLength</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">drop</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>递归的精髓在于：值是基于问题的子集逐次建立的。另外需要强调的一点是：<strong>递归不能改变传递给他们的参数</strong></p><hr><h2 id="purity-immutability-and-policies-for-change"><a href="#purity-immutability-and-policies-for-change" aria-hidden="true" class="header-anchor">#</a> Purity, Immutability, and Policies for Change</h2><p>函数式编程不仅仅只关心编程，也思考如何尽量降低软件复杂性。而降低软件复杂性的一种方式就是<strong>减少或者消除程序中的状态变化</strong>。</p><h3 id="purity-纯度"><a href="#purity-纯度" aria-hidden="true" class="header-anchor">#</a> Purity -- 纯度</h3><p>我们先来看一个不纯的函数，利用 <code>_.random()</code> 来生成一个一定长度的随机小写 ASCII 字符串和数字。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> rand <span class="token operator">=</span> <span class="token function">partialOne</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>random<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 创建一个大于0的伪随机数</span>

<span class="token keyword">function</span> <span class="token function">randString</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> ascii <span class="token operator">=</span> <span class="token function">repeatly</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> <span class="token function">partial</span><span class="token punctuation">(</span>rand<span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> ascii<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>n <span class="token operator">=&gt;</span> n<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">randString</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment">// 可能是 &quot;f&quot;</span>
</code></pre></div><p>接下来，我们来看一下 pure function 的定义：</p><ul><li>结果只能从他的参数的值计算而来</li><li>不能依赖能被外部操作改变的数据</li><li>不能改变外部数据的状态</li></ul><p>那我们来看 <code>randString()</code> 这个例子，违反了第一条规则。最后返回的结果的计算当中，没有使用任何参数；也违反了第二条规则，因为它的结果完全依赖于外部提供的随机数生成器。</p><blockquote><p>我们常用的 <code>map()</code>、<code>reduce()</code> 是纯函数的典型例子。</p></blockquote><p>JavaScript 的 <code>Math.rand()</code> 方法从设计上就是<em>不纯</em>的，因此任何使用该函数的函数也都是不纯的，此外比如还有 <code>Date.now()</code>、<code>console.log</code>、<code>this</code> 和全局变量等。因为 JavaScript 到处传递着对象的引用，因此每一个接收对象和数组作为参数的函数都可能是不纯的。在 JavaScript 的世界中，完全纯的函数可能是不存在的，但也完全不必如此。</p><p>但是，我们可以<strong>尽可能地使得函数更纯</strong>。也就是 Separating the Pure from the Impure。</p><p>比如我们将 <code>randString()</code> 划分为两个函数：一个随机生成字符，一个拼装字符串。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">generateRandomCharacter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toSting</span><span class="token punctuation">(</span><span class="token number">36</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">generateString</span><span class="token punctuation">(</span>charGen<span class="token punctuation">,</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">repeatedly</span> <span class="token punctuation">(</span>len<span class="token punctuation">,</span> charGen<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> composedRandomString <span class="token operator">=</span> <span class="token function">partialOne</span><span class="token punctuation">(</span>generateRandomCharacter<span class="token punctuation">,</span> generateString<span class="token punctuation">)</span>

<span class="token function">composedRandomString</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
</code></pre></div><p>如何，便把所有纯的部分(即 <code>generateString()</code>)封装在函数内。</p><h4 id="纯函数的优点"><a href="#纯函数的优点" aria-hidden="true" class="header-anchor">#</a> 纯函数的优点</h4><p>我们有一个定义如下：当一个函数的返回值只依赖它的参数时，被称为具有 <em>referential transparency</em>。</p><p>在这里，我们将谈一下纯函数的好处。之前我们定义了一个 <code>nth()</code> 的函数，借此我们来定义一个 <code>second()</code> 函数来返回数组的第二个元素。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">second</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">nth</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>nth()</code> 是一个纯函数(完全满足纯函数的定义)，唯一的依赖就只有数组参数。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">nth</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>
</code></pre></div><p>这段代码无论运行多少次，只要 <code>nth()</code> 接收数组<code>[1,2,3,4]</code> 和数字 <code>1</code>，总是返回结果 <code>2</code>。通常，<code>nth()</code> 也永远不会修改传给它的数组。</p><p>当你知道纯函数的这种性质后，替换掉纯函数就不会影响到其他的外部状态的变化。比如，我们可以直接替换掉 <code>nth()</code> 函数，而保持功能完全一致，这简直是轻而易举。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">second</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="纯度和幂等性"><a href="#纯度和幂等性" aria-hidden="true" class="header-anchor">#</a> 纯度和幂等性</h4><p>幂等性(Idempotence)指的是：将函数执行无数次，和执行一次的效果相同。优点类似于下面这个结构：</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token function">fun</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">compose</span><span class="token punctuation">(</span>fun<span class="token punctuation">,</span> fun<span class="token punctuation">)</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
</code></pre></div><p>以上面的 <code>second()</code> 函数为例，假设 <code>let a = [1, [10,20,30],3]</code>，运行一次得到的结果是数组<code>[10,20,30]</code>，运行两次的结果是值<code>20</code>，这就说明，函数 <code>second()</code> 并不是幂等的。</p><h3 id="immutability-不变性"><a href="#immutability-不变性" aria-hidden="true" class="header-anchor">#</a> Immutability -- 不变性</h3><p>JavaScript 中很少有默认不变的数据类型，字符串是其中一类。</p><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">'iloveyuer'</span>
s<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
s <span class="token comment">// 'iloveyuer'</span>
</code></pre></div></div><div class="page-edit"><div class="edit-link"><a href="https://github.com/maoxiaoke/xiaokedada/edit/master/ReadingNote/Functional-JavaScript.md" target="_blank" rel="noopener noreferrer">在 Github 上编辑此页</a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div><div class="last-updated"><span class="prefix">上次更新: </span><span class="time">5/17/2018, 11:54:25 AM</span></div></div><!----></div></div></div>
    <script src="/assets/js/1.92a2d4aa.js" defer></script><script src="/assets/js/app.410137e2.js" defer></script>
  </body>
</html>
