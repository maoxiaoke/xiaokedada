<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>XIAOKEDADA | 让人头疼的函数内this的指向</title>
    <meta name="description" content="Write something useful and funny">
    <link rel="icon" href="/favicon.png">
    
    <link rel="preload" href="/assets/css/30.styles.10e620a8.css" as="style"><link rel="preload" href="/assets/js/app.ec8cb532.js" as="script"><link rel="preload" href="/assets/js/9.99bd33ef.js" as="script"><link rel="prefetch" href="/assets/js/16.9c55aefb.js"><link rel="prefetch" href="/assets/js/1.162133cf.js"><link rel="prefetch" href="/assets/js/2.7f6e95e5.js"><link rel="prefetch" href="/assets/js/3.29ffa0c3.js"><link rel="prefetch" href="/assets/js/4.555fb419.js"><link rel="prefetch" href="/assets/js/5.82b8b310.js"><link rel="prefetch" href="/assets/js/6.9c9601dc.js"><link rel="prefetch" href="/assets/js/7.29a07879.js"><link rel="prefetch" href="/assets/js/8.ba8d6d00.js"><link rel="prefetch" href="/assets/js/10.047d1b3e.js"><link rel="prefetch" href="/assets/js/11.7d737150.js"><link rel="prefetch" href="/assets/js/12.844f07ec.js"><link rel="prefetch" href="/assets/js/13.71525fcf.js"><link rel="prefetch" href="/assets/js/14.08d6aa82.js"><link rel="prefetch" href="/assets/js/15.cdaa6d65.js"><link rel="prefetch" href="/assets/js/0.8a6b8cb7.js"><link rel="prefetch" href="/assets/js/17.d3061b7b.js"><link rel="prefetch" href="/assets/js/18.21d355f2.js"><link rel="prefetch" href="/assets/js/19.179f193c.js"><link rel="prefetch" href="/assets/js/20.e61fe5fc.js"><link rel="prefetch" href="/assets/js/21.d97c7737.js"><link rel="prefetch" href="/assets/js/22.71e3e54c.js"><link rel="prefetch" href="/assets/js/23.2925e108.js"><link rel="prefetch" href="/assets/js/24.efc2c6f7.js"><link rel="prefetch" href="/assets/js/25.28d6d514.js"><link rel="prefetch" href="/assets/js/26.8aeaffe5.js"><link rel="prefetch" href="/assets/js/27.5665d8a6.js"><link rel="prefetch" href="/assets/js/28.06883965.js"><link rel="prefetch" href="/assets/js/29.356c6349.js">
    <link rel="stylesheet" href="/assets/css/30.styles.10e620a8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      XIAOKEDADA
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/JavaScript/" class="nav-link router-link-active">JavaScript</a></div><div class="nav-item"><a href="/FirstMeet/" class="nav-link">FirstMeet系列</a></div><div class="nav-item"><a href="/CSS/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/ReadingNote/" class="nav-link">读书笔记</a></div><div class="nav-item"><a href="/GatherAll/" class="nav-link">Resource</a></div><a href="https://github.com/maoxiaoke/xiaokedada" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/JavaScript/" class="nav-link router-link-active">JavaScript</a></div><div class="nav-item"><a href="/FirstMeet/" class="nav-link">FirstMeet系列</a></div><div class="nav-item"><a href="/CSS/" class="nav-link">CSS</a></div><div class="nav-item"><a href="/ReadingNote/" class="nav-link">读书笔记</a></div><div class="nav-item"><a href="/GatherAll/" class="nav-link">Resource</a></div><a href="https://github.com/maoxiaoke/xiaokedada" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav><ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Depth-in-Series</span><!----></p><ul class="sidebar-group-items"><li><a href="/JavaScript/Require-and-Import.html" class="sidebar-link">require 和 import 的难点</a></li><li><a href="/JavaScript/Property-Descriptors.html" class="sidebar-link">JavaScript 对象的 Property descriptors</a></li><li><a href="/JavaScript/Depth-in-ES6.html" class="sidebar-link">深入理解 ES6</a></li><li><a href="/JavaScript/Depth-in-This.html" class="active sidebar-link">让人头疼的函数内this的指向</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/Depth-in-This.html#默认绑定-default-binding" class="sidebar-link">默认绑定 -- Default binding</a></li><li class="sidebar-sub-header"><a href="/JavaScript/Depth-in-This.html#隐式绑定-implicit-binding" class="sidebar-link">隐式绑定 -- Implicit Binding</a></li><li class="sidebar-sub-header"><a href="/JavaScript/Depth-in-This.html#显式绑定-explicit-binding" class="sidebar-link">显式绑定 -- Explicit Binding</a></li><li class="sidebar-sub-header"><a href="/JavaScript/Depth-in-This.html#new-绑定-new-binding" class="sidebar-link">new 绑定 -- new Binding</a></li><li class="sidebar-sub-header"><a href="/JavaScript/Depth-in-This.html#四种规则的顺序" class="sidebar-link">四种规则的顺序</a></li><li class="sidebar-sub-header"><a href="/JavaScript/Depth-in-This.html#特殊的-this" class="sidebar-link">特殊的 this</a></li><li class="sidebar-sub-header"><a href="/JavaScript/Depth-in-This.html#call、apply-和-bind" class="sidebar-link">call、apply 和 bind</a></li><li class="sidebar-sub-header"><a href="/JavaScript/Depth-in-This.html#new-的四个步骤" class="sidebar-link">new 的四个步骤</a></li></ul></li><li><a href="/JavaScript/Depth-in-Closure.html" class="sidebar-link">来一次痛痛快快得闭包挑战</a></li><li><a href="/JavaScript/Async-Programming.html" class="sidebar-link">JavaScript 异步编程</a></li><li><a href="/JavaScript/Prototype.html" class="sidebar-link">再谈原型和继承</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>基础内容</span><!----></p><ul class="sidebar-group-items"><li><a href="/JavaScript/AJAX.html" class="sidebar-link">AJAX</a></li><li><a href="/JavaScript/Coercion.html" class="sidebar-link">强制类型转换</a></li><li><a href="/JavaScript/Map-and-Reduce.html" class="sidebar-link">JavaScript 的 map/reduce</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>DOM 相关</span><!----></p><ul class="sidebar-group-items"><li><a href="/JavaScript/DOM-Operation.html" class="sidebar-link">原生JavaScript的DOM操作</a></li><li><a href="/JavaScript/DOM-More.html" class="sidebar-link">再来仔细研究DOM</a></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>Thinking-in-JavaScript</span><!----></p><ul class="sidebar-group-items"><li><a href="/JavaScript/Small-and-Chunk-Code.html" class="sidebar-link">书写有用而优雅的代码</a></li></ul></div></li></ul></div><div class="page"><div class="content"><h1 id="让人头疼的函数内this的指向"><a href="#让人头疼的函数内this的指向" aria-hidden="true" class="header-anchor">#</a> 让人头疼的函数内this的指向</h1><p>JavaScript 颇让费解的东西 this 为何出现呢，机制是<strong>提供更优雅的方式来隐式地“传递”一个对象引用</strong>。对于 this 的很多误解和使用，建议收看 <a href="https://github.com/getify/You-Dont-Know-JS" target="_blank" rel="noopener noreferrer">You-Dont-Know-JS</a>。本文主要是在它的基础上整合的内容。</p><p>每个函数在被调用时都会自动取得两个特殊的变量: this 和 arguments。需要说明的是，this 不是编写时绑定，而是<strong>运行时</strong>绑定。它依赖于函数调用的上下文条件。this 绑定与函数声明的位置没有任何关系，而与函数被调用的方式紧密相连。</p><p>首先，提到台面上来。<strong>this 是一个完全根据调用点(call-site)来为函数调用建立绑定。</strong></p><blockquote><p>这句话不太好理解</p></blockquote><p>决定 this 的指向有四种规则。</p><h2 id="默认绑定-default-binding"><a href="#默认绑定-default-binding" aria-hidden="true" class="header-anchor">#</a> 默认绑定 -- Default binding</h2><p>这种 this 规则是在没有其他规则适用情况下的默认规则。</p><p>最常见的情况就是： 独立函数调用。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//函数的调用点</span>
</code></pre><p>foo() 被一个直白的，毫无修饰的函数引用(即 foo，对于命名函数来讲，它就是一个引用)调用的，所以 this 指向全局对象(Global)。</p><blockquote><p>如果 strict mode 在这里生效，那么对于<em>默认绑定</em>来说全局对象是不合法的，所以 this 将被设置为 undefined。</p></blockquote><hr><h2 id="隐式绑定-implicit-binding"><a href="#隐式绑定-implicit-binding" aria-hidden="true" class="header-anchor">#</a> 隐式绑定 -- Implicit Binding</h2><p>第二种规则是考虑<strong>调用点是否有一个上下文对象(context object)</strong>。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    foo<span class="token punctuation">:</span> foo
<span class="token punctuation">}</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用点</span>
</code></pre><p>foo() 被声明然后作为引用属性添加到 obj。调用点使用 obj 这个上下文(环境) 来调用 foo() 函数，可以说 obj 对象在函数被调用的时间点上“拥有”或“包含”这个函数引用。所以，obj 就是 foo() 调用的 this。</p><p><strong>敲黑板，划重点了</strong></p><h3 id="隐式丢失-implicitly-lost"><a href="#隐式丢失-implicitly-lost" aria-hidden="true" class="header-anchor">#</a> 隐式丢失 -- Implicitly Lost</h3><p>当一个 隐式绑定丢失了它的绑定，这通常意味着它会退回到 默认绑定。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    foo<span class="token punctuation">:</span> foo
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> obj<span class="token punctuation">.</span>foo<span class="token punctuation">;</span> <span class="token comment">// 函数引用！</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;oops, global&quot;</span><span class="token punctuation">;</span> <span class="token comment">// `a` 也是一个全局对象的属性</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;oops, global&quot;</span>
</code></pre><p>尽管 bar 似乎是 obj.foo 的引用，但实际上它只是另一个 foo 本身的引用而已。<strong>起作用的调用点是 bar()</strong>，一个直白，毫无修饰的调用。所以，默认绑定适用在这里。</p><p>更意外的一种方式是当我们考虑<strong>传递一个回调函数</strong>时:</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">doFoo</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// `fn` 只不过 `foo` 的另一个引用</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- 调用点!</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    foo<span class="token punctuation">:</span> foo
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;oops, global&quot;</span><span class="token punctuation">;</span> <span class="token comment">// `a` 也是一个全局对象的属性</span>
<span class="token function">doFoo</span><span class="token punctuation">(</span> obj<span class="token punctuation">.</span>foo <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;oops, global&quot;</span>
</code></pre><p>和上面的例子一致，fn 不过是 foo 的另一个引用，所以结果和上面的例子一样。</p><hr><h2 id="显式绑定-explicit-binding"><a href="#显式绑定-explicit-binding" aria-hidden="true" class="header-anchor">#</a> 显式绑定 -- Explicit Binding</h2><p>如果你想强制一个函数调用使用某个特定对象作为 this 绑定，具体地说，函数拥有 <code>call()</code> 和 <code>apply()</code> 方法，它们提供一些特殊的功能。你创建的所有函数，都可以访问 call() 和 apply()。</p><p>这些工具接收的第一个参数都是一个用于 this 的对象，之后使用这个指定的 this 来调用函数。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre><p>但是，单独依靠 显式绑定 并不能解决函数“丢失”自己原本的 this 绑定的这个问题。</p><blockquote><p>??? why??</p></blockquote><p>我们还是用一个回调函数来讨论一下:</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    foo<span class="token punctuation">:</span> foo
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;oops, global&quot;</span><span class="token punctuation">;</span> <span class="token comment">// `a` 也是一个全局对象的属性</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span> obj<span class="token punctuation">.</span>foo<span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;oops, global&quot;</span>
</code></pre><p>在我们的函数调用点处产生了 隐式丢失 的情况。如果此处我们使用显式绑定 <code>call()</code>。</p><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span> obj<span class="token punctuation">.</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//throw new TypeError('&quot;callback&quot; argument must be a function');</span>
</code></pre><p>报错的信息是<em>回调参数必须是一个函数</em>。所以我们改成这样就顺利通过了。</p><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;oops, global&quot;</span>
</code></pre><h3 id="硬绑定-hard-binding"><a href="#硬绑定-hard-binding" aria-hidden="true" class="header-anchor">#</a> 硬绑定 -- Hard Binding</h3><p>Hard binding 是 明确绑定 的一个变种。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span> bar<span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre><blockquote><p><code>bar</code> 将 <code>foo</code> 的 <code>this</code> 在函数内部强制绑定到 <code>obj</code>。之后，无论怎样调用函数 <code>bar()</code>，它总是手动使用 obj 调用 foo。这种绑定态度明确又坚定，所以称之为 hard binding。</p></blockquote><p>hard binding 的用法一：为所有传入的参数和传出的的返回值创建一个通道</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> something <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> something<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> <span class="token function-variable function">bar</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> foo<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> obj<span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 3</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span>
</code></pre><p>hard binding 的用法二：创建一个可复用的帮助函数</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> something <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> something<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 简单的 `bind` 帮助函数</span>
<span class="token keyword">function</span> <span class="token function">bind</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span> obj<span class="token punctuation">,</span> arguments <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span> foo<span class="token punctuation">,</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 3</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span>
</code></pre><p>正因为 harding 是一个如此常用的模式，ES5 将它作为内建工具提供: <code>Function.prototype.bind</code>。</p><p>比如上面的例子。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> something <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">+</span> something<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span> <span class="token number">3</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2 3</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> b <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span>
</code></pre><p>在比如我们 隐式丢失 的那个例子:</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    foo<span class="token punctuation">:</span> foo
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">&quot;oops, global&quot;</span><span class="token punctuation">;</span> <span class="token comment">// `a` 也是一个全局对象的属性</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span> obj<span class="token punctuation">.</span>foo<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;oops, global&quot;</span>
</code></pre><hr><h2 id="new-绑定-new-binding"><a href="#new-绑定-new-binding" aria-hidden="true" class="header-anchor">#</a> new 绑定 -- new Binding</h2><p>这是最后一种 this 绑定规则。在 JavaScript 中，“构造器”仅仅是一个函数，也叫做构造函数。不依附于类，也不初始化一个类，甚至都不是一种特殊的函数种类。本质是一般的函数，只是被使用 <code>new</code> 来调用时改变了行为。</p><p>在函数前面加入 new 调用时，会自动完成下面的事情:</p><ul><li>一个全新的对象被构建</li><li>这个新构建的对象会被接入原型链</li><li>新构建的对象被设置为函数调用的 this 绑定</li><li>除非函数返回一个它自己的其他对象，否则这个被 new 调用的函数将自动返回这个新构建的对象</li></ul><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span> <span class="token number">2</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> bar<span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre><hr><h2 id="四种规则的顺序"><a href="#四种规则的顺序" aria-hidden="true" class="header-anchor">#</a> 四种规则的顺序</h2><ol><li>函数是通过 new 被调用的吗(new 绑定)？如果是，this 就是新构建的对象。</li></ol><pre class="language-js"><code><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><ol start="2"><li>函数是通过 call 或 apply 被调用(显式绑定)，甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。</li></ol><pre class="language-js"><code><span class="token keyword">var</span> bar <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> obj2 <span class="token punctuation">)</span>
</code></pre><ol start="3"><li>函数是通过上下文对象(也称为拥有者或容器对象)被调用的吗(隐式绑定)？如果是，this 就是那个环境对象</li></ol><pre class="language-js"><code><span class="token keyword">var</span> bar <span class="token operator">=</span> obj1<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><ol start="4"><li>否则，使用默认的 this(默认绑定)。如果在 strict mode 下，就是 undefined，否则是 global 对象。</li></ol><pre class="language-js"><code><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><hr><h2 id="特殊的-this"><a href="#特殊的-this" aria-hidden="true" class="header-anchor">#</a> 特殊的 this</h2><h3 id="在闭包中使用-this"><a href="#在闭包中使用-this" aria-hidden="true" class="header-anchor">#</a> 在闭包中使用 this</h3><p>匿名函数的执行环境具有全局性，因此其 this 对象<strong>通常</strong>指向 global 对象。</p><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">/*
    ... 这些范围内，this 指向 obj
    */</span>
    <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/*
        ... 这些范围内，this 指向 global
        */</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> test<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a <span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    foo<span class="token punctuation">:</span>foo
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//0</span>
</code></pre><p>这种情况其实也是可以使用我们的四个规则来进行判断的，首先看我们的调用点。第一个调用点是 <code>obj.foo()</code> 这种是满足我们 隐式绑定规则的，this 指向我们的 obj。接着我们的第二个调用点是 <code>obj.foo()()</code>，这种是非常直白的函数调用，所以退回到 默认绑定，this 指向 global 对象。上面的例子和下面的写法一致，但是表意更清楚。</p><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">/*
    ... 这些范围内，this 指向 obj
    */</span>
    <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/*
        ... 这些范围内，this 指向 global
        */</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> test<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a <span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    foo<span class="token punctuation">:</span>foo
<span class="token punctuation">}</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>我们通常采用<strong>将外部的 this 保存到一个闭包能访问的变量里</strong>来访问该对象。</p><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token comment">/*
    ... 这些范围内，this 指向 obj
    */</span>
    <span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/*
        ... 这些范围内，this 指向 global
        */</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> test<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a <span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    foo<span class="token punctuation">:</span>foo
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre><p>这似乎是不错的解决方案，但都是为了逃避 this 而非接受它。</p><h3 id="iife-中使用-this"><a href="#iife-中使用-this" aria-hidden="true" class="header-anchor">#</a> IIFE 中使用 this</h3><p>通常说，IIFE 中的 this 指向 global 对象。下面是一个非常简单的 IIFE 函数。</p><pre class="language-js"><code><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>
        self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>但是，上述的代码和下面的代码没有任何区别:</p><pre class="language-js"><code><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>
        self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>很浅显了吧，非常直白的 默认绑定。</p><h3 id="传递-null-或-undefined"><a href="#传递-null-或-undefined" aria-hidden="true" class="header-anchor">#</a> 传递 null 或 undefined</h3><p>如果你传递 null 或 undefined 作为 call、apply 或 bind 的 this 绑定参数，那么这些值会被忽略掉，取而代之的是 默认绑定 规则将适用于这个调用。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> <span class="token keyword">null</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre><h3 id="箭头函数"><a href="#箭头函数" aria-hidden="true" class="header-anchor">#</a> 箭头函数</h3><p>ES6 的箭头函数和上述四种规则不同的是，<strong>箭头函数从封闭它的(函数或全局)作用域采用 this 绑定。</strong></p><p>最常见的用法是用于回调。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 这里的 `this` 是词法上从 `foo()` 采用</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre><p>箭头函数提供除了使用 <code>bind()</code> 外，另外一种在函数上来确保 this 的方式。但是这种写法和我们上面提到的 <code>self = this</code> 并无二致。也就是说，上面的代码和下面的代码效果一致:</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre><p>没啥区别，对吧。所以，总的来说，都和这四种规则分不开。</p><hr><h2 id="call、apply-和-bind"><a href="#call、apply-和-bind" aria-hidden="true" class="header-anchor">#</a> call、apply 和 bind</h2><p><code>call()</code> 和 <code>apply()</code> 的区别不再赘述，我们这里想要关注的是 <strong>它们的返回值</strong>。返回值是它们与 <code>bind()</code> 函数的区别。在 MDN 中，是这样描述的:</p><blockquote><p>The result of calling the function with the specified this value and arguments. -- MDN</p></blockquote><p>官方文档的描述在这里: <a href="http://es5.github.io/#x15.3" target="_blank" rel="noopener noreferrer">Function.prototype.apply</a></p><blockquote><p>Return the result of calling the [[Call]] internal method of func, providing thisArg as the this value and argList as the list of arguments. -- [ES5]</p></blockquote><p>两者表达一个意思，就是返回 <strong>调用函数的使用特定的 this 和参数所返回的结果</strong>。</p><p>举个例子:</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span>b<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2 'yuer'</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'yuer'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//undefined</span>
</code></pre><p>调用函数 <code>foo()</code> 没有返回值，所以返回的是 <code>undefined</code>。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span>b<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//2 'yuer'</span>
    <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'yuer'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{ name: 'yuer' }</span>
</code></pre><p><code>foo()</code> 有返回值，所以返回 <code>foo()</code> 的返回值。</p><p>而，<code>bind()</code> 函数返回的是一个 <strong>新的函数</strong>。</p><blockquote><p>The bind method takes one or more arguments, thisArg and (optionally) arg1, arg2, etc, and returns a new function. -- -- [ES5]</p></blockquote><p>也就是说，参数设置 <code>bind()</code> 和 <code>call()</code> 是一样的，但是，<code>bind()</code> 返回一个函数的拷贝。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span>b<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">2</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'yuer'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//[Function: bound foo]</span>
</code></pre><p>这也就解释了我们上面提到的 <em>call() 和 apply() 无法解决隐式绑定丢失的问题</em>，就是因为要求返回的是一个函数，而 <code>bind()</code> 正好有这个功能。</p><hr><h2 id="new-的四个步骤"><a href="#new-的四个步骤" aria-hidden="true" class="header-anchor">#</a> new 的四个步骤</h2><ul><li>一个全新的对象被构建</li><li>这个新构建的对象会被接入原型链</li><li>新构建的对象被设置为函数调用的 this 绑定</li><li>除非函数返回一个它自己的其他对象，否则这个被 new 调用的函数将自动返回这个新构建的对象</li></ul><p>这四句话看似简单，实则意义深刻。</p><p>第一句，new 出来的是一个新对象。第二句，对象被接入原型链？怎么接入，使用 <code>__prototype__</code>。第三句，将对象作为构造函数调用的 this 绑定。至此，我们来模拟一下:</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
Fun<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Fun<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'yuer'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">objectFac</span><span class="token punctuation">(</span>Fun<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> Fun<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    Fun<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> per <span class="token operator">=</span> <span class="token function">objectFac</span><span class="token punctuation">(</span>Fun<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>per<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'yuer'</span>
</code></pre><p>这个看似不错，但是这是一种简单的使用原型来构建对象的一种方法。更一般的，我们是组合使用构造函数模式和原型模式。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Fun</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Fun<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    constructor<span class="token punctuation">:</span> Fun<span class="token punctuation">;</span>
    getName<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>这种情况下，我们将 Fun 作为 arguments 的一部分来进行传递。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Fun</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Fun<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    constructor<span class="token punctuation">:</span> Fun<span class="token punctuation">,</span>
    getName<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">objectFac</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> Constructor <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shift<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// arguments 是一个类数组，所以不能直接用数组方法，但是可以借用 Array.prototype 上的方法</span>
    <span class="token comment">//var Constructor = Array.prototype.shift.call(arguments);</span>
    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> Constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    Constructor<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可以简单地将 arguments 作为参数传递，但是没有办法使用数组方法</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> per <span class="token operator">=</span> <span class="token function">objectFac</span><span class="token punctuation">(</span>Fun<span class="token punctuation">,</span><span class="token string">'yuer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>per<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>上述代码实现了 new 操作符的第一、二和三步。即，创建新的对象、接入原型链、改变 this 的指向。那第四部如何理解呢？我们看一下简化例子:</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Fun</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        who<span class="token punctuation">:</span> <span class="token string">'xiaoke'</span><span class="token punctuation">,</span>
        what<span class="token punctuation">:</span> <span class="token string">'love'</span><span class="token punctuation">,</span>
        how<span class="token punctuation">:</span> <span class="token string">'yuer'</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Fun<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    constructor<span class="token punctuation">:</span> Fun<span class="token punctuation">,</span>
    getName<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> per <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fun</span><span class="token punctuation">(</span><span class="token string">'yuer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>per<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { who: 'xiaoke', what: 'love', how: 'yuer' }</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
</code></pre><p>构造函数有返回值，我们只能访问返回内容中的属性。这也就是 new 操作符的第四项内容。然后我们要如何处理 objectFun() 函数呢，也就是说，我们需要判断构造函数是否有返回值，如果有，就返回构造函数的内容。</p><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Fun</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        who<span class="token punctuation">:</span> <span class="token string">'xiaoke'</span><span class="token punctuation">,</span>
        what<span class="token punctuation">:</span> <span class="token string">'love'</span><span class="token punctuation">,</span>
        how<span class="token punctuation">:</span> <span class="token string">'yuer'</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Fun<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    constructor<span class="token punctuation">:</span> Fun<span class="token punctuation">,</span>
    getName<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">objectFac</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//var Constructor= Array.prototype.shift.call(arguments);</span>
    <span class="token keyword">var</span> Constructor <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>shift<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> Constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
    <span class="token keyword">var</span> ret <span class="token operator">=</span> Constructor<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token keyword">typeof</span> ret <span class="token operator">==</span> <span class="token string">'object'</span> <span class="token operator">?</span> ret <span class="token punctuation">:</span> obj<span class="token punctuation">;</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token keyword">var</span> per <span class="token operator">=</span> <span class="token function">objectFac</span><span class="token punctuation">(</span>Fun<span class="token punctuation">,</span><span class="token string">'yuer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//var per = new Fun('yuer');</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>per<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>参考</p><ul><li>《You Don't Know JS》</li><li>《JavaScript 高级程序设计》</li><li><a href="https://github.com/jawil/blog/issues/16" target="_blank" rel="noopener noreferrer">不用call和apply方法模拟实现ES5的bind方法</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener noreferrer">JavaScript深入之new的模拟实现</a></li></ul></div><div class="content edit-link"><a href="https://github.com/maoxiaoke/xiaokedada/edit/master//JavaScript/Depth-in-This.md" target="_blank" rel="noopener noreferrer">在 Github 上编辑此页</a><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div><div class="content page-nav"><p class="inner"><span class="prev">
        ← <a href="/JavaScript/Depth-in-ES6.html" class="prev">
          深入理解 ES6
        </a></span><span class="next"><a href="/JavaScript/Depth-in-Closure.html">
          来一次痛痛快快得闭包挑战
        </a> →
      </span></p></div></div></div></div>
    <script src="/assets/js/9.99bd33ef.js" defer></script><script src="/assets/js/app.ec8cb532.js" defer></script>
  </body>
</html>
