(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{267:function(a,t,r){"use strict";r.r(t);var e=r(0),i=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"dynamic-programming"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dynamic-programming","aria-hidden":"true"}},[a._v("#")]),a._v(" Dynamic Programming")]),r("ol",[r("li",[a._v("试图仅解决子问题一次（从而减少计算量）")]),r("li",[a._v("Bottom-up approach")])]),r("h2",{attrs:{id:"适用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#适用场景","aria-hidden":"true"}},[a._v("#")]),a._v(" 适用场景")]),r("p",[a._v("常适用于 "),r("strong",[a._v("重叠子问题(Overlapping Sub-problems)")]),a._v(" 和 "),r("strong",[a._v("最优子结构(Optimal SubStructure)")]),a._v(" 性质的问题。")]),r("p",[a._v("具有重叠子问题：如果一个问题可以分解为多个可重复的子问题，或该问题的递归算法解决相同的子问题而不是生成新的子问题。称这样的问题具有 "),r("em",[a._v("重叠子问题")]),a._v("。")]),r("p",[a._v("具有最优子结构：如果一个问题可以分解为子问题，并通过找到子问题的最优解，从而得到问题的最优解。称这样的问题具有 "),r("em",[a._v("最优子结构")]),a._v("。")]),r("h2",{attrs:{id:"“三步走”-解题法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#“三步走”-解题法","aria-hidden":"true"}},[a._v("#")]),a._v(" “三步走” 解题法")]),r("h3",{attrs:{id:"思考-“三步走”"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#思考-“三步走”","aria-hidden":"true"}},[a._v("#")]),a._v(" 思考 “三步走”")]),r("ol",[r("li",[a._v("定义 DP 数组")]),r("li",[a._v("状态转移方程")]),r("li",[a._v("找初始值")])]),r("h3",{attrs:{id:"编码-“三步走”"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#编码-“三步走”","aria-hidden":"true"}},[a._v("#")]),a._v(" 编码 “三步走”")]),r("ol",[r("li",[a._v("处理特判")]),r("li",[a._v("初始化 DP")]),r("li",[a._v("实现状态转移方程 + 边界处理")])]),r("p",[a._v("// TODO: DP vs 分治 vs 递归")])])}],!1,null,null,null);t.default=i.exports}}]);